<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
  <title>DODGE AI - Browser Game Where the AI Learns How You Dodge</title>
  <meta name="description" content="A bullet hell browser game where the AI studies your dodge patterns and adapts to kill you. Free, no download, plays in any browser.">
  <meta name="robots" content="index, follow">
  <meta name="theme-color" content="#06060f">
  <link rel="canonical" href="https://dodgeai.example.com">

  <!-- Open Graph -->
  <meta property="og:title" content="DODGE AI - The AI That Learns How You Dodge">
  <meta property="og:description" content="A bullet hell browser game where the AI studies your patterns and adapts. How long can you survive?">
  <meta property="og:type" content="website">
  <meta property="og:url" content="https://dodgeai.example.com">
  <meta property="og:image" content="https://dodgeai.example.com/og-image.png">
  <meta property="og:image:width" content="1200">
  <meta property="og:image:height" content="630">
  <meta property="og:image:alt" content="DODGE AI - A bullet hell browser game where the AI learns how you dodge">

  <!-- Twitter Card -->
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="DODGE AI - The AI That Learns How You Dodge">
  <meta name="twitter:description" content="A bullet hell browser game where the AI studies your patterns and adapts. How long can you survive?">
  <meta name="twitter:image" content="https://dodgeai.example.com/og-image.png">

  <!-- Structured Data -->
  <script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "VideoGame",
    "name": "DODGE AI",
    "description": "A browser-based bullet hell game where an AI learns how you dodge and adapts to kill you. Features pattern detection, adaptive difficulty, and 6 escalating phases.",
    "url": "https://dodgeai.example.com",
    "genre": ["Bullet Hell", "Action", "Browser Game"],
    "gamePlatform": ["Web Browser"],
    "operatingSystem": "Any",
    "applicationCategory": "Game",
    "playMode": "SinglePlayer",
    "numberOfPlayers": {
      "@type": "QuantitativeValue",
      "value": 1
    },
    "offers": {
      "@type": "Offer",
      "price": "0",
      "priceCurrency": "USD"
    },
    "author": {
      "@type": "Person",
      "name": "Zee"
    }
  }
  </script>

  <style>
    :root {
      --sa-top: env(safe-area-inset-top, 0px);
      --sa-bottom: env(safe-area-inset-bottom, 0px);
      --sa-left: env(safe-area-inset-left, 0px);
      --sa-right: env(safe-area-inset-right, 0px);
    }

    html {
      overscroll-behavior: none;
    }

    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      background: #06060f;
      overflow: hidden;
      font-family: 'Courier New', monospace;
      color: #e0e0e0;
      -webkit-touch-callout: none;
      cursor: default;
      overscroll-behavior: none;
    }

    canvas {
      display: block;
      position: fixed;
      top: 0; left: 0;
      z-index: 1;
      cursor: none;
      pointer-events: none;
      touch-action: none;
      -webkit-user-select: none;
      user-select: none;
    }
    canvas.active { pointer-events: auto; }

    /* --- HUD --- */
    #hud {
      position: fixed;
      top: max(16px, calc(8px + var(--sa-top)));
      left: max(16px, calc(8px + var(--sa-left)));
      z-index: 10;
      pointer-events: none;
    }

    #hud-time {
      font-size: 32px;
      font-weight: bold;
      color: #00f0ff;
      text-shadow: 0 0 20px rgba(0,240,255,0.5);
      letter-spacing: 2px;
    }

    #hud-phase {
      font-size: 13px;
      color: #8b5cf6;
      margin-top: 4px;
      letter-spacing: 1px;
      text-transform: uppercase;
    }

    #hud-dodged {
      font-size: 11px;
      color: #555;
      margin-top: 2px;
    }

    /* --- Power-up HUD --- */
    #hud-powerups {
      position: fixed;
      bottom: max(16px, calc(8px + var(--sa-bottom)));
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 8px;
      z-index: 10;
      pointer-events: none;
    }

    .powerup-indicator {
      display: none;
      align-items: center;
      gap: 6px;
      padding: 6px 12px;
      border-radius: 20px;
      font-size: 11px;
      font-weight: bold;
      letter-spacing: 1px;
      text-transform: uppercase;
    }

    .powerup-indicator.active { display: flex; }

    .powerup-indicator .pu-bar {
      width: 40px; height: 4px;
      background: rgba(255,255,255,0.15);
      border-radius: 2px;
      overflow: hidden;
    }

    .powerup-indicator .pu-bar-fill {
      height: 100%;
      border-radius: 2px;
      transition: width 0.1s linear;
    }

    #pu-slowmo { background: rgba(59,130,246,0.2); color: #3b82f6; border: 1px solid rgba(59,130,246,0.3); }
    #pu-slowmo .pu-bar-fill { background: #3b82f6; }
    #pu-shrink { background: rgba(236,72,153,0.2); color: #ec4899; border: 1px solid rgba(236,72,153,0.3); }
    #pu-shrink .pu-bar-fill { background: #ec4899; }
    #pu-magnet { background: rgba(249,115,22,0.2); color: #f97316; border: 1px solid rgba(249,115,22,0.3); }
    #pu-magnet .pu-bar-fill { background: #f97316; }
    #pu-vortex { background: rgba(168,85,247,0.2); color: #a855f7; border: 1px solid rgba(168,85,247,0.3); }
    #pu-vortex .pu-bar-fill { background: #a855f7; }

    /* --- AI Brain Panel --- */
    #brain-panel {
      position: fixed;
      top: max(16px, calc(8px + var(--sa-top)));
      right: max(16px, calc(8px + var(--sa-right)));
      width: 200px;
      background: rgba(10, 10, 30, 0.85);
      border: 1px solid rgba(139, 92, 246, 0.3);
      border-radius: 8px;
      padding: 12px;
      z-index: 10;
      pointer-events: none;
      backdrop-filter: blur(8px);
    }

    #brain-panel h3 {
      font-size: 10px;
      color: #8b5cf6;
      letter-spacing: 2px;
      text-transform: uppercase;
      margin-bottom: 10px;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    #brain-panel h3::before {
      content: '';
      width: 6px; height: 6px;
      background: #8b5cf6;
      border-radius: 50%;
      display: inline-block;
      animation: pulse-dot 1.5s infinite;
    }

    @keyframes pulse-dot {
      0%, 100% { opacity: 1; box-shadow: 0 0 4px #8b5cf6; }
      50% { opacity: 0.4; box-shadow: none; }
    }

    .brain-row {
      display: flex;
      justify-content: space-between;
      font-size: 11px;
      margin-bottom: 6px;
    }

    .brain-label { color: #666; }
    .brain-value { color: #ccc; }

    #brain-bias {
      display: grid;
      grid-template-columns: 1fr 1fr 1fr;
      grid-template-rows: 1fr 1fr 1fr;
      gap: 2px;
      width: 72px;
      height: 72px;
      margin: 8px auto;
    }

    .bias-cell {
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 9px;
      border-radius: 3px;
    }

    .bias-cell.active {
      background: rgba(139, 92, 246, 0.15);
      color: #8b5cf6;
    }

    .bias-center {
      background: rgba(0, 240, 255, 0.1);
      border-radius: 50%;
    }

    #brain-insight {
      font-size: 10px;
      color: #8b5cf6;
      margin-top: 8px;
      font-style: italic;
      min-height: 28px;
      line-height: 1.3;
    }

    /* --- Announcements --- */
    #phase-announce, #boss-announce {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 20;
      text-align: center;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.3s;
    }

    #phase-announce.show, #boss-announce.show { opacity: 1; }

    #phase-announce .phase-num {
      font-size: 14px;
      color: #8b5cf6;
      letter-spacing: 4px;
      text-transform: uppercase;
    }

    #phase-announce .phase-name {
      font-size: 36px;
      font-weight: bold;
      color: #fff;
      text-shadow: 0 0 40px rgba(139, 92, 246, 0.6);
      margin-top: 4px;
    }

    #phase-announce .phase-desc {
      font-size: 13px;
      color: #888;
      margin-top: 8px;
    }

    #boss-announce .boss-title {
      font-size: 28px;
      font-weight: bold;
      color: #ff3355;
      letter-spacing: 4px;
      text-shadow: 0 0 40px rgba(255,51,85,0.6);
      animation: boss-pulse 0.5s ease-in-out infinite alternate;
    }

    #boss-announce .boss-sub {
      font-size: 12px;
      color: #ff6633;
      margin-top: 6px;
      letter-spacing: 2px;
    }

    @keyframes boss-pulse {
      from { transform: scale(1); }
      to { transform: scale(1.05); }
    }

    #pickup-announce {
      position: fixed;
      top: 40%;
      left: 50%;
      transform: translateX(-50%);
      z-index: 20;
      text-align: center;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.2s;
      font-size: 18px;
      font-weight: bold;
      letter-spacing: 2px;
    }

    #pickup-announce.show { opacity: 1; }

    /* --- Start Screen --- */
    #start-screen {
      position: fixed;
      inset: 0;
      z-index: 50;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background: rgba(6, 6, 15, 0.88);
    }

    #start-screen.hidden { display: none; }

    #start-screen h1 {
      font-size: 52px;
      font-weight: bold;
      color: #fff;
      letter-spacing: 6px;
      text-shadow: 0 0 40px rgba(0, 240, 255, 0.4);
    }

    #start-screen h1 span { color: #8b5cf6; }

    #start-screen .tagline {
      color: #666;
      font-size: 14px;
      margin-top: 8px;
      letter-spacing: 1px;
    }

    #start-screen .best-time {
      color: #8b5cf6;
      font-size: 13px;
      margin-top: 20px;
      min-height: 18px;
    }

    .menu-buttons {
      display: flex;
      flex-direction: column;
      gap: 10px;
      margin-top: 28px;
      align-items: center;
    }

    .menu-btn {
      padding: 12px 40px;
      background: transparent;
      border: 1px solid rgba(255,255,255,0.15);
      color: #888;
      font-family: 'Courier New', monospace;
      font-size: 13px;
      letter-spacing: 2px;
      cursor: pointer;
      border-radius: 4px;
      transition: all 0.2s;
      min-width: 220px;
      text-align: center;
    }

    .menu-btn:hover {
      background: rgba(255,255,255,0.05);
      border-color: rgba(255,255,255,0.3);
      color: #ccc;
    }

    .menu-btn.primary {
      padding: 14px 48px;
      border-color: rgba(0, 240, 255, 0.4);
      color: #00f0ff;
      font-size: 16px;
      letter-spacing: 3px;
    }

    .menu-btn.primary:hover {
      background: rgba(0, 240, 255, 0.1);
      border-color: #00f0ff;
      box-shadow: 0 0 20px rgba(0, 240, 255, 0.2);
    }

    .menu-btn.small {
      padding: 8px 20px;
      font-size: 10px;
      color: #555;
      border-color: rgba(255,255,255,0.08);
      min-width: auto;
      margin-top: 20px;
    }

    .menu-btn.small:hover {
      color: #ff3355;
      border-color: rgba(255,51,85,0.3);
    }

    /* --- Mute Button --- */
    #mute-btn {
      position: fixed;
      top: max(16px, calc(8px + var(--sa-top)));
      right: max(230px, calc(220px + var(--sa-right)));
      z-index: 15;
      background: rgba(10, 10, 30, 0.7);
      border: 1px solid rgba(255,255,255,0.15);
      border-radius: 50%;
      width: 32px; height: 32px;
      display: flex; align-items: center; justify-content: center;
      cursor: pointer;
      color: #888;
      font-size: 16px;
      transition: all 0.2s;
    }
    #mute-btn:hover { border-color: rgba(255,255,255,0.3); color: #ccc; }
    #mute-btn.muted { color: #ff3355; border-color: rgba(255,51,85,0.3); }

    /* --- Heat Bar --- */
    #heat-bar-container {
      position: fixed;
      top: max(60px, calc(52px + var(--sa-top)));
      left: max(16px, calc(8px + var(--sa-left)));
      z-index: 10;
      pointer-events: none;
      width: 120px;
    }
    #heat-label {
      font-size: 9px;
      color: #666;
      letter-spacing: 1px;
      text-transform: uppercase;
    }
    #heat-bar {
      width: 100%;
      height: 4px;
      background: rgba(255,255,255,0.05);
      border-radius: 2px;
      margin-top: 2px;
      overflow: hidden;
    }
    #heat-bar-fill {
      height: 100%;
      width: 0%;
      border-radius: 2px;
      transition: width 0.1s linear, background 0.3s;
    }
    #heat-tier {
      font-size: 10px;
      font-weight: bold;
      letter-spacing: 2px;
      margin-top: 2px;
      min-height: 14px;
    }

    .start-hint { color: #444; font-size: 11px; margin-top: 16px; }

    /* --- Modals --- */
    .modal-overlay {
      position: fixed;
      inset: 0;
      z-index: 60;
      display: none;
      align-items: center;
      justify-content: center;
      background: rgba(6, 6, 15, 0.92);
      backdrop-filter: blur(4px);
    }

    .modal-overlay.show { display: flex; }

    .modal-content {
      background: rgba(15, 15, 35, 0.95);
      border: 1px solid rgba(139, 92, 246, 0.2);
      border-radius: 8px;
      padding: 28px;
      max-width: 480px;
      width: 90%;
      max-height: 80vh;
      overflow-y: auto;
      position: relative;
    }

    .modal-content h2 {
      font-size: 16px;
      color: #8b5cf6;
      letter-spacing: 3px;
      text-transform: uppercase;
      margin-bottom: 16px;
    }

    .modal-content p, .modal-content li {
      font-size: 12px;
      color: #999;
      line-height: 1.6;
      margin-bottom: 8px;
    }

    .modal-content h3 {
      font-size: 12px;
      color: #00f0ff;
      letter-spacing: 1px;
      margin-top: 16px;
      margin-bottom: 8px;
    }

    .modal-content ul { list-style: none; padding-left: 0; }
    .modal-content li::before { content: '\203A'; color: #8b5cf6; margin-right: 8px; }

    .modal-close {
      position: absolute;
      top: 12px; right: 12px;
      background: none;
      border: none;
      color: #555;
      font-size: 18px;
      cursor: pointer;
      font-family: 'Courier New', monospace;
      transition: color 0.2s;
    }

    .modal-close:hover { color: #fff; }

    .feedback-area {
      width: 100%;
      min-height: 100px;
      background: rgba(0,0,0,0.3);
      border: 1px solid rgba(139, 92, 246, 0.2);
      border-radius: 4px;
      color: #ccc;
      font-family: 'Courier New', monospace;
      font-size: 12px;
      padding: 10px;
      resize: vertical;
      margin-bottom: 12px;
    }

    .feedback-area:focus { outline: none; border-color: rgba(139, 92, 246, 0.5); }

    .feedback-submit {
      padding: 8px 24px;
      background: rgba(139, 92, 246, 0.2);
      border: 1px solid rgba(139, 92, 246, 0.3);
      color: #8b5cf6;
      font-family: 'Courier New', monospace;
      font-size: 11px;
      letter-spacing: 1px;
      cursor: pointer;
      border-radius: 4px;
      transition: all 0.2s;
    }

    .feedback-submit:hover { background: rgba(139, 92, 246, 0.3); border-color: #8b5cf6; }

    .stats-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
      margin-top: 12px;
    }

    .stat-item {
      text-align: center;
      padding: 12px;
      background: rgba(0,0,0,0.2);
      border-radius: 6px;
      border: 1px solid rgba(255,255,255,0.05);
    }

    .stat-val { font-size: 20px; font-weight: bold; color: #fff; }
    .stat-label { font-size: 9px; color: #666; margin-top: 4px; text-transform: uppercase; letter-spacing: 1px; }

    .bests-list {
      margin-top: 16px;
      text-align: left;
    }

    .bests-list h3 {
      color: #facc15;
      font-family: 'Courier New', monospace;
      font-size: 0.9rem;
      margin-bottom: 8px;
      letter-spacing: 1px;
    }

    .bests-list ol {
      list-style: none;
      padding: 0;
      margin: 0;
      font-family: 'Courier New', monospace;
      font-size: 0.85rem;
    }

    .bests-list li {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 6px 0;
      border-bottom: 1px solid rgba(255, 255, 255, 0.05);
      color: #ccc;
    }

    .bests-list li:last-child {
      border-bottom: none;
    }

    .bests-list .best-rank {
      color: #666;
      width: 24px;
      flex-shrink: 0;
    }

    .bests-list .best-time {
      color: #00f0ff;
      font-weight: bold;
      flex-shrink: 0;
    }

    .bests-list .best-date {
      color: #666;
      font-size: 0.8rem;
    }

    .bests-list .bests-empty {
      color: #555;
      font-style: italic;
      padding: 8px 0;
    }

    /* --- Game Over --- */
    #gameover-screen {
      position: fixed;
      inset: 0;
      z-index: 50;
      display: none;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background: rgba(6, 6, 15, 0.95);
      backdrop-filter: blur(4px);
    }

    #gameover-screen.show { display: flex; }

    #gameover-screen .go-title {
      font-size: 14px;
      color: #ff3355;
      letter-spacing: 4px;
      text-transform: uppercase;
    }

    #gameover-screen .go-time {
      font-size: 56px;
      font-weight: bold;
      color: #fff;
      margin-top: 8px;
      text-shadow: 0 0 30px rgba(255, 51, 85, 0.3);
    }

    #gameover-screen .go-time span { font-size: 20px; color: #888; }
    #gameover-screen .go-phase { font-size: 13px; color: #8b5cf6; margin-top: 4px; }

    .go-stats { display: flex; gap: 32px; margin-top: 24px; }
    .go-stat { text-align: center; }
    .go-stat-val { font-size: 24px; font-weight: bold; color: #fff; }
    .go-stat-label { font-size: 10px; color: #666; margin-top: 2px; text-transform: uppercase; letter-spacing: 1px; }
    .go-new-best { color: #00f0ff; font-size: 12px; margin-top: 12px; letter-spacing: 2px; }
    .go-buttons { display: flex; gap: 12px; margin-top: 28px; }

    .go-btn {
      padding: 12px 32px;
      background: transparent;
      border: 1px solid rgba(255, 255, 255, 0.2);
      color: #ccc;
      font-family: 'Courier New', monospace;
      font-size: 13px;
      letter-spacing: 2px;
      cursor: pointer;
      border-radius: 4px;
      transition: all 0.2s;
    }

    .go-btn:hover { background: rgba(255, 255, 255, 0.05); border-color: rgba(255, 255, 255, 0.4); }
    .go-btn.primary { border-color: rgba(0, 240, 255, 0.4); color: #00f0ff; }
    .go-btn.primary:hover { background: rgba(0, 240, 255, 0.1); border-color: #00f0ff; }

    .go-ai-learned {
      color: #444;
      font-size: 11px;
      margin-top: 20px;
      max-width: 320px;
      text-align: center;
      line-height: 1.4;
    }

    #go-killed-by {
      font-size: 12px;
      letter-spacing: 1px;
      margin-top: 10px;
      font-family: 'Courier New', monospace;
      text-transform: uppercase;
    }

    /* --- Ad Zone Placeholder --- */
    .ad-zone {
      position: fixed;
      bottom: 0; left: 0; right: 0;
      height: 60px;
      background: rgba(0,0,0,0.7);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 5;
      border-top: 1px solid #1a1a2e;
    }

    .ad-zone span { color: #333; font-size: 10px; letter-spacing: 2px; text-transform: uppercase; }

    /* Mobile adjustments */
    @media (max-width: 600px) {
      #brain-panel { width: 150px; padding: 8px; top: max(8px, calc(4px + var(--sa-top))); right: max(8px, calc(4px + var(--sa-right))); }
      #brain-panel h3 { font-size: 9px; }
      .brain-row { font-size: 10px; }
      #brain-bias { width: 54px; height: 54px; }
      #hud { top: max(8px, calc(4px + var(--sa-top))); left: max(8px, calc(4px + var(--sa-left))); }
      #hud-time { font-size: 24px; }
      #phase-announce .phase-name { font-size: 28px; }
      #mute-btn { right: max(170px, calc(160px + var(--sa-right))); width: 28px; height: 28px; font-size: 14px; }
      #heat-bar-container { top: max(50px, calc(42px + var(--sa-top))); width: 90px; }
    }

    /* --- SEO Content (below fold) --- */
    .seo-content {
      position: absolute;
      left: -9999px;
      pointer-events: none;
      max-width: 800px;
      margin: 0 auto;
      padding: 60px 24px 80px;
      color: #b0b0b0;
      font-family: 'Courier New', monospace;
      line-height: 1.7;
    }

    .seo-content h1 {
      color: #00f0ff;
      font-size: 1.8rem;
      margin-bottom: 24px;
      line-height: 1.3;
    }

    .seo-content h2 {
      color: #8b5cf6;
      font-size: 1.2rem;
      margin-top: 32px;
      margin-bottom: 12px;
    }

    .seo-content p {
      margin-bottom: 16px;
      max-width: 65ch;
    }

    .seo-content ul {
      list-style: none;
      padding: 0;
      margin-bottom: 16px;
    }

    .seo-content ul li {
      padding-left: 20px;
      position: relative;
      margin-bottom: 8px;
    }

    .seo-content ul li::before {
      content: '>';
      position: absolute;
      left: 0;
      color: #00f0ff;
    }

    .seo-content .seo-footer {
      margin-top: 48px;
      padding-top: 24px;
      border-top: 1px solid #1a1a2e;
      color: #555;
      font-size: 0.85rem;
    }
  </style>
</head>
<body>

<canvas id="game"></canvas>

<!-- HUD -->
<div id="hud">
  <div id="hud-time">0.0s</div>
  <div id="hud-phase">PHASE 1 — SCANNING</div>
  <div id="hud-dodged">Dodged: 0</div>
</div>

<!-- Power-up indicators -->
<div id="hud-powerups">
  <div class="powerup-indicator" id="pu-slowmo">BULLET TIME <div class="pu-bar"><div class="pu-bar-fill" id="pu-slowmo-bar"></div></div></div>
  <div class="powerup-indicator" id="pu-shrink">SMOL MODE <div class="pu-bar"><div class="pu-bar-fill" id="pu-shrink-bar"></div></div></div>
  <div class="powerup-indicator" id="pu-vortex">BLACK HOLE <div class="pu-bar"><div class="pu-bar-fill" id="pu-vortex-bar"></div></div></div>
  <div class="powerup-indicator" id="pu-magnet">PERSONAL SPACE <div class="pu-bar"><div class="pu-bar-fill" id="pu-magnet-bar"></div></div></div>
</div>

<!-- Mute Button -->
<button id="mute-btn" title="Toggle Sound">&#9834;</button>

<!-- Heat Bar -->
<div id="heat-bar-container" style="display:none">
  <div id="heat-label">HEAT</div>
  <div id="heat-bar"><div id="heat-bar-fill"></div></div>
  <div id="heat-tier"></div>
</div>

<!-- AI Brain Panel -->
<div id="brain-panel">
  <h3>AI Brain</h3>
  <div class="brain-row">
    <span class="brain-label">Confidence</span>
    <span class="brain-value" id="brain-confidence">0%</span>
  </div>
  <div class="brain-row">
    <span class="brain-label">Threat</span>
    <span class="brain-value" id="brain-threat">0%</span>
  </div>
  <div class="brain-row">
    <span class="brain-label">Patterns</span>
    <span class="brain-value" id="brain-patterns">0</span>
  </div>
  <div class="brain-row">
    <span class="brain-label">Reaction</span>
    <span class="brain-value" id="brain-reaction">—</span>
  </div>
  <div class="brain-row">
    <span class="brain-label">Samples</span>
    <span class="brain-value" id="brain-samples">0</span>
  </div>
  <div id="brain-bias">
    <div class="bias-cell"></div>
    <div class="bias-cell active" id="bias-up"></div>
    <div class="bias-cell"></div>
    <div class="bias-cell active" id="bias-left"></div>
    <div class="bias-cell bias-center"></div>
    <div class="bias-cell active" id="bias-right"></div>
    <div class="bias-cell"></div>
    <div class="bias-cell active" id="bias-down"></div>
    <div class="bias-cell"></div>
  </div>
  <div id="brain-insight">Sizing you up...</div>
</div>

<!-- Phase Announcement -->
<div id="phase-announce">
  <div class="phase-num"></div>
  <div class="phase-name"></div>
  <div class="phase-desc"></div>
</div>

<!-- Boss Announcement -->
<div id="boss-announce">
  <div class="boss-title">BOSS INCOMING</div>
  <div class="boss-sub">Survive or EMP it</div>
</div>

<!-- Powerup Pickup -->
<div id="pickup-announce"></div>

<!-- Mobile Ability Button -->
<button id="ability-btn" style="
  position: fixed; bottom: 80px; right: 20px;
  width: 50px; height: 50px; border-radius: 50%;
  background: rgba(0, 255, 170, 0.15); border: 2px solid rgba(0, 255, 170, 0.4);
  color: #00ffaa; font-size: 18px; font-weight: bold;
  display: none; z-index: 100; touch-action: manipulation;
  font-family: monospace;
">AB</button>

<!-- Start Screen / Menu -->
<div id="start-screen">
  <h1>DODGE <span>AI</span></h1>
  <div class="tagline">Maximum effort. Minimum survival.</div>
  <div class="best-time" id="start-best"></div>
  <div class="menu-buttons">
    <button class="menu-btn primary" id="btn-start">PLAY</button>
    <button class="menu-btn" id="btn-howto">HOW TO PLAY</button>
    <button class="menu-btn" id="btn-stats">STATS</button>
    <button class="menu-btn" id="btn-contact">CONTACT</button>
    <button class="menu-btn" id="btn-feedback">FEEDBACK</button>
  </div>
  <button class="menu-btn small" id="btn-reset-ai">RESET AI</button>
  <div class="start-hint">Mouse or touch. Try not to cry.</div>
</div>

<!-- How to Play Modal -->
<div class="modal-overlay" id="modal-howto">
  <div class="modal-content">
    <button class="modal-close" data-close="modal-howto">&times;</button>
    <h2>The Briefing</h2>
    <p>Oh hey. So you want instructions. Adorable.</p>
    <p><strong>Move</strong> your mouse. <strong>Don't die.</strong> That's the whole TED talk. You're welcome.</p>
    <p>The AI is watching everything you do. Every panicky little dodge, every predictable little pattern. It's basically your browser history but weaponized.</p>
    <p>See those <strong style="color:#facc15">shiny floating orbs</strong>? Grab them. They do cool stuff. I'm not gonna hold your hand through every single one — this isn't a Marvel movie where they explain the plot three times.</p>
    <p>Every 25 seconds a <strong style="color:#ff3355">boss</strong> rolls in like it owns the place. Each one's different. Each one thinks you're its personal piñata.</p>
    <p style="color:#666; margin-top:12px;">Spoiler alert: you're going to die. A lot. But like a beautiful, regenerating phoenix... you'll hit retry.</p>
  </div>
</div>

<!-- Stats Modal -->
<div class="modal-overlay" id="modal-stats">
  <div class="modal-content">
    <button class="modal-close" data-close="modal-stats">&times;</button>
    <h2>Stats</h2>
    <div class="stats-grid" id="stats-grid"></div>
  </div>
</div>

<!-- Feedback Modal -->
<div class="modal-overlay" id="modal-feedback">
  <div class="modal-content">
    <button class="modal-close" data-close="modal-feedback">&times;</button>
    <h2>Talk to Me</h2>
    <p>Go ahead, roast me. Compliment me. Tell me the AI killed you unfairly. I'll pretend to care. (Saved locally — I'm not that kind of app.)</p>
    <textarea class="feedback-area" id="feedback-text" placeholder="Your hot take goes here..."></textarea>
    <button class="feedback-submit" id="btn-submit-feedback">SEND IT</button>
    <div id="feedback-status" style="font-size:11px;color:#10b981;margin-top:8px;display:none">Filed under 'stuff I'll actually read.' Thanks.</div>
  </div>
</div>

<!-- Game Over Screen -->
<div id="gameover-screen">
  <div class="go-title">Wow. That happened.</div>
  <div class="go-time" id="go-time">12.4<span>s</span></div>
  <div class="go-phase" id="go-phase">Reached Phase 3 — PREDICTING</div>
  <div class="go-stats">
    <div class="go-stat">
      <div class="go-stat-val" id="go-dodged">47</div>
      <div class="go-stat-label">Near-Death Experiences</div>
    </div>
    <div class="go-stat">
      <div class="go-stat-val" id="go-closest">—</div>
      <div class="go-stat-label">Closest Call</div>
    </div>
    <div class="go-stat">
      <div class="go-stat-val" id="go-games">1</div>
      <div class="go-stat-label">Lives Wasted</div>
    </div>
  </div>
  <div class="go-new-best" id="go-new-best" style="display:none">NEW PERSONAL BEST. I'M GENUINELY IMPRESSED.</div>
  <div class="go-buttons">
    <button class="go-btn" id="btn-share">SHARE</button>
    <button class="go-btn primary" id="btn-retry">RETRY</button>
    <button class="go-btn" id="btn-menu">MENU</button>
  </div>
  <div class="go-ai-learned" id="go-ai-learned"></div>
  <div id="go-killed-by"></div>
  <div id="go-ability-unlock" style="display:none; color:#00ffaa; font-size:14px; letter-spacing:2px; margin-top:10px; text-shadow: 0 0 12px rgba(0,255,170,0.5); font-weight:bold;"></div>
  <div id="go-abilities" style="display:none; color:#555; font-size:11px; margin-top:6px; letter-spacing:1px;"></div>
</div>

<!-- Ad Zone Placeholder -->
<div class="ad-zone" id="ad-zone" style="display:none">
  <span>Ad Space</span>
</div>

<!-- SEO Content (below fold, visible to crawlers) -->
<section class="seo-content" aria-label="About DODGE AI">
  <h1>DODGE AI -- Browser Game Where the AI Learns How You Play</h1>

  <p>DODGE AI is a bullet hell browser game with one twist: the AI is watching. Every dodge you make, every safe zone you hide in, every panic move you pull -- the AI catalogs it all and uses it against you.</p>

  <h2>How to Play</h2>
  <p>Move your cursor (or finger on mobile) to dodge incoming projectiles. Survive as long as you can while the AI ramps up the pressure across 6 escalating phases.</p>
  <ul>
    <li>Move with mouse or touch -- your character follows</li>
    <li>Dodge projectiles: homing, splitters, bouncers, waves, and more</li>
    <li>Collect power-ups: Bullet Time, EMP, Ghost Mode, Blink, and others</li>
    <li>Defeat bosses that appear every 25 seconds</li>
    <li>Survive the AI's adaptive attacks as it learns your patterns</li>
  </ul>

  <h2>The AI That Learns</h2>
  <p>This is not a scripted difficulty curve. The AI Brain tracks your dodge direction bias, preferred zones, reaction time, and movement patterns in real time. It remembers you across sessions. Come back tomorrow and it already knows your habits.</p>
  <ul>
    <li>Pattern detection: clockwise dodging, corner hugging, panic reversals</li>
    <li>Counter-attacks: targeted projectiles aimed at your safe zones</li>
    <li>Adaptive difficulty: adjusts aggression based on your skill level</li>
    <li>Persistent memory: the AI remembers returning players via localStorage</li>
  </ul>

  <h2>Features</h2>
  <ul>
    <li>6 escalating phases from SCANNING to EVOLVED</li>
    <li>Multiple projectile types with unique behaviors</li>
    <li>Boss fights with health bars and attack patterns</li>
    <li>5 power-ups including Bullet Time, EMP, and Black Hole vortex</li>
    <li>AI brain panel showing live analysis of your play style</li>
    <li>No download required -- plays directly in your browser</li>
    <li>Works on desktop and mobile</li>
    <li>Free to play, no account needed</li>
  </ul>

  <div class="seo-footer">
    <p>DODGE AI is a free browser game. No download, no login, no tracking cookies. Just you versus an AI that gets smarter every round.</p>
  </div>
</section>

<script>
// ============================================================
// DODGE AI — Survive the Learning Machine (v3)
// ============================================================

// Utility: Stack-with-decay weighting — recent samples weighted heavier
function decayWeight(sampleTime, currentTime) {
  const age = currentTime - sampleTime;
  if (age < 10) return 3.0;
  if (age < 20) return 2.0;
  if (age < 30) return 1.0;
  return 0.5;
}

// Utility: Convert radian angle to cardinal/ordinal direction name
function getDirectionName(angle) {
  // Normalize angle to [0, 2*PI)
  const a = ((angle % (2 * Math.PI)) + 2 * Math.PI) % (2 * Math.PI);
  const sector = Math.round(a / (Math.PI / 4)) % 8;
  const names = ['RIGHT', 'LOWER-RIGHT', 'BELOW', 'LOWER-LEFT', 'LEFT', 'UPPER-LEFT', 'ABOVE', 'UPPER-RIGHT'];
  return names[sector];
}

// Personal best list management (top 5 survival times)
const BESTS_KEY = 'dodge-ai-bests';
const MAX_BESTS = 5;

function loadBests() {
  try {
    return JSON.parse(localStorage.getItem(BESTS_KEY)) || [];
  } catch { return []; }
}

function saveBest(gameTime) {
  const bests = loadBests();
  bests.push({
    time: parseFloat(gameTime.toFixed(1)),
    date: new Date().toISOString().slice(0, 10),
  });
  bests.sort((a, b) => b.time - a.time);
  const top5 = bests.slice(0, MAX_BESTS);
  localStorage.setItem(BESTS_KEY, JSON.stringify(top5));
  return top5;
}

function migrateBestTime() {
  const oldBest = parseFloat(localStorage.getItem('dodge-ai-best'));
  const newBests = localStorage.getItem(BESTS_KEY);
  if (oldBest > 0 && !newBests) {
    localStorage.setItem(BESTS_KEY, JSON.stringify([{
      time: oldBest,
      date: 'legacy',
      daily: false,
    }]));
  }
}

// Analytics: fire-and-forget event tracking via GoatCounter
// All calls are guarded -- never throws, never blocks gameplay
function trackEvent(name, title) {
  try {
    if (window.goatcounter && window.goatcounter.count) {
      window.goatcounter.count({
        path: name,
        title: title || name,
        event: true,
      });
    }
  } catch (e) {
    // Silently ignore -- analytics must never affect gameplay
  }
}

const PHASE_DEFS = [
  { name: 'SCANNING',    dur: 20, color: '#ff3355', desc: 'The AI is taking notes. Like a really creepy diary.',
    spawnRate: 1.2,  count: 2, speed: 3.5,  aimPct: 0.25, burstChance: 0,    homingChance: 0,    splitterChance: 0,    bouncerChance: 0,    waveChance: 0,    accelChance: 0,    spiralChance: 0,    clusterChance: 0,    mineChance: 0 },
  { name: 'TARGETING',   dur: 20, color: '#ff6633', desc: 'It knows your name now. And your dodging habits.',
    spawnRate: 0.8,  count: 2, speed: 3.8,  aimPct: 0.7,  burstChance: 0.25, homingChance: 0,    splitterChance: 0,    bouncerChance: 0.15, waveChance: 0,    accelChance: 0,    spiralChance: 0,    clusterChance: 0,    mineChance: 0 },
  { name: 'PREDICTING',  dur: 20, color: '#8b5cf6', desc: 'Shooting where you WILL be. Basically precrime.',
    spawnRate: 0.65, count: 3, speed: 4.5,  aimPct: 0.8,  burstChance: 0.3,  homingChance: 0.1,  splitterChance: 0.2,  bouncerChance: 0.15, waveChance: 0,    accelChance: 0.1,  spiralChance: 0.1,  clusterChance: 0,    mineChance: 0 },
  { name: 'TIMING',      dur: 20, color: '#3b82f6', desc: 'It timed your reflexes. This is getting personal.',
    spawnRate: 0.55, count: 3, speed: 5.0,  aimPct: 0.85, burstChance: 0.35, homingChance: 0.15, splitterChance: 0.2,  bouncerChance: 0.15, waveChance: 0.1,  accelChance: 0.2,  spiralChance: 0.15, clusterChance: 0.1,  mineChance: 0 },
  { name: 'HUNTING',     dur: 30, color: '#14b8a6', desc: 'Homing missiles. Because regular death was too boring.',
    spawnRate: 0.45, count: 4, speed: 5.5,  aimPct: 0.9,  burstChance: 0.4,  homingChance: 0.25, splitterChance: 0.25, bouncerChance: 0.2,  waveChance: 0.15, accelChance: 0.2,  spiralChance: 0.15, clusterChance: 0.15, mineChance: 0.1 },
  { name: 'EVOLVED',     dur: Infinity, color: '#e879f9', desc: 'Full Skynet mode. You had a good run. Emphasis on had.',
    spawnRate: 0.35, count: 4, speed: 6.0,  aimPct: 0.95, burstChance: 0.45, homingChance: 0.3,  splitterChance: 0.3,  bouncerChance: 0.2,  waveChance: 0.2,  accelChance: 0.25, spiralChance: 0.2,  clusterChance: 0.2,  mineChance: 0.15 },
];

// Deep-copy for evolved ramp so we don't mutate the originals
const EVOLVED_BASE = { ...PHASE_DEFS[5] };

const PLAYER_RADIUS = 10;
const PROJECTILE_RADIUS = 5;
const PLAYER_LERP = 0.12;
const WARNING_DURATION = 350;
const PHASE_ANNOUNCE_DURATION = 2000;
const BOSS_ANNOUNCE_DURATION = 1500;
const BOSS_INTERVAL = 25; // seconds between bosses
const BOSS_LIFETIME = 12; // seconds a boss lives

const POWERUP_TYPES = {
  slowmo:    { name: 'BULLET TIME',    color: '#3b82f6', duration: 8,   icon: 'S' },
  emp:       { name: 'KABOOM',        color: '#facc15', duration: 0,   icon: 'E' },
  shrink:    { name: 'SMOL MODE',     color: '#ec4899', duration: 10,  icon: 'K' },
  magnet:    { name: 'PERSONAL SPACE', color: '#f97316', duration: 7,   icon: 'R' },
  vortex:    { name: 'BLACK HOLE',    color: '#a855f7', duration: 8,   icon: 'V' },
};

const POWERUP_SPAWN_MIN = 7;
const POWERUP_SPAWN_MAX = 13;
const POWERUP_LIFETIME = 6;
const POWERUP_RADIUS = 16;

// ============================================================
// Pattern Detectors (feed into AIBrain for counter-pattern firing)
// ============================================================

class DirectionBiasDetector {
  constructor() {
    this.samples = []; // { direction, angle, time }
    this.maxSamples = 100;
    this._lastCalloutDirection = null;
  }

  update(dx, dy, gameTime) {
    const dist = Math.sqrt(dx * dx + dy * dy);
    if (dist < 3) return;
    const angle = Math.atan2(dy, dx);
    let direction;
    if (angle > -0.785 && angle <= 0.785) direction = 'right';
    else if (angle > 0.785 && angle <= 2.356) direction = 'down';
    else if (angle > -2.356 && angle <= -0.785) direction = 'up';
    else direction = 'left';
    this.samples.push({ direction, angle, time: gameTime });
    if (this.samples.length > this.maxSamples) this.samples.shift();
  }

  getActivePattern(gameTime) {
    if (this.samples.length < 15) return null;
    const counts = { left: 0, right: 0, up: 0, down: 0 };
    let totalWeight = 0;
    for (const s of this.samples) {
      const w = decayWeight(s.time, gameTime);
      counts[s.direction] += w;
      totalWeight += w;
    }
    const entries = Object.entries(counts).sort((a, b) => b[1] - a[1]);
    const dominantPct = (entries[0][1] / totalWeight) * 100;
    if (dominantPct < 32) return null;

    let cwCount = 0, ccwCount = 0;
    const recent = this.samples.slice(-30);
    for (let i = 1; i < recent.length; i++) {
      let diff = recent[i].angle - recent[i - 1].angle;
      while (diff > Math.PI) diff -= 2 * Math.PI;
      while (diff < -Math.PI) diff += 2 * Math.PI;
      if (diff > 0.1) cwCount++;
      else if (diff < -0.1) ccwCount++;
    }
    const rotationBias = cwCount > ccwCount * 1.5 ? 'clockwise' : ccwCount > cwCount * 1.5 ? 'counterclockwise' : null;

    return {
      type: 'direction-bias',
      direction: entries[0][0],
      pct: Math.round(dominantPct),
      rotation: rotationBias,
      confidence: Math.min(1, this.samples.length / 60),
    };
  }

  serialize() {
    const pattern = this.getActivePattern(this.samples.length > 0 ? this.samples[this.samples.length - 1].time : 0);
    return pattern ? { direction: pattern.direction, rotation: pattern.rotation } : null;
  }
  deserialize(data) {}
}

class SafeZoneDetector {
  constructor() {
    this.visits = [];
    this.maxVisits = 200;
    this.zoneNames = ['top-left', 'top-center', 'top-right', 'mid-left', 'center', 'mid-right', 'bottom-left', 'bottom-center', 'bottom-right'];
  }

  update(px, py, gameTime, w, h) {
    const zx = Math.min(2, Math.floor((px / w) * 3));
    const zy = Math.min(2, Math.floor((py / h) * 3));
    const zone = zy * 3 + zx;
    this.visits.push({ zone, time: gameTime });
    if (this.visits.length > this.maxVisits) this.visits.shift();
  }

  getActivePattern(gameTime) {
    if (this.visits.length < 20) return null;
    const counts = new Array(9).fill(0);
    let totalWeight = 0;
    for (const v of this.visits) {
      const w = decayWeight(v.time, gameTime);
      counts[v.zone] += w;
      totalWeight += w;
    }
    let maxIdx = 0;
    for (let i = 1; i < 9; i++) if (counts[i] > counts[maxIdx]) maxIdx = i;
    const dominantPct = (counts[maxIdx] / totalWeight) * 100;
    if (dominantPct < 20) return null;

    return {
      type: 'safe-zone',
      zone: maxIdx,
      zoneName: this.zoneNames[maxIdx],
      pct: Math.round(dominantPct),
      confidence: Math.min(1, this.visits.length / 100),
    };
  }

  getZoneCenter(zone, w, h) {
    const zx = zone % 3;
    const zy = Math.floor(zone / 3);
    return { x: (zx + 0.5) * (w / 3), y: (zy + 0.5) * (h / 3) };
  }

  serialize() {
    const pattern = this.getActivePattern(this.visits.length > 0 ? this.visits[this.visits.length - 1].time : 0);
    return pattern ? { zone: pattern.zone, zoneName: pattern.zoneName } : null;
  }
  deserialize(data) {}
}

class DodgeSequenceDetector {
  constructor() {
    this.sequences = [];
    this.currentSeq = '';
    this.seqStartTime = 0;
    this.maxSeqs = 30;
    this.lastDirTime = 0;
  }

  update(dx, dy, gameTime) {
    const dist = Math.sqrt(dx * dx + dy * dy);
    if (dist < 3) return;
    const angle = Math.atan2(dy, dx);
    let dir;
    if (angle > -0.785 && angle <= 0.785) dir = 'R';
    else if (angle > 0.785 && angle <= 2.356) dir = 'D';
    else if (angle > -2.356 && angle <= -0.785) dir = 'U';
    else dir = 'L';

    if (gameTime - this.lastDirTime > 1.5 || this.currentSeq.length >= 6) {
      if (this.currentSeq.length >= 3) {
        this.sequences.push({ dirs: this.currentSeq, time: gameTime });
        if (this.sequences.length > this.maxSeqs) this.sequences.shift();
      }
      this.currentSeq = '';
      this.seqStartTime = gameTime;
    }

    if (this.currentSeq.length === 0 || this.currentSeq[this.currentSeq.length - 1] !== dir) {
      this.currentSeq += dir;
    }
    this.lastDirTime = gameTime;
  }

  getActivePattern(gameTime) {
    if (this.sequences.length < 5) return null;

    const freqMap = {};
    for (const seq of this.sequences) {
      for (let i = 0; i <= seq.dirs.length - 3; i++) {
        const sub = seq.dirs.substring(i, i + 3);
        freqMap[sub] = (freqMap[sub] || 0) + decayWeight(seq.time, gameTime);
      }
    }

    let bestSeq = null, bestScore = 0;
    for (const [seq, score] of Object.entries(freqMap)) {
      if (score > bestScore) { bestScore = score; bestSeq = seq; }
    }

    if (!bestSeq || bestScore < 4) return null;

    const dirNames = { R: 'right', L: 'left', U: 'up', D: 'down' };
    const readable = bestSeq.split('').map(d => dirNames[d]).join('-');

    return {
      type: 'dodge-sequence',
      sequence: bestSeq,
      readable: readable,
      score: Math.round(bestScore),
      confidence: Math.min(1, bestScore / 10),
    };
  }

  predictNext(currentDir) {
    const pattern = this.getActivePattern(this.lastDirTime);
    if (!pattern) return null;
    const seq = pattern.sequence;
    const idx = seq.indexOf(currentDir);
    if (idx >= 0 && idx < seq.length - 1) {
      return seq[idx + 1];
    }
    return null;
  }

  serialize() {
    const pattern = this.getActivePattern(this.lastDirTime);
    return pattern ? { sequence: pattern.sequence } : null;
  }
  deserialize(data) {}
}

class PanicDetector {
  constructor() {
    this.speedSamples = [];
    this.reversals = [];
    this.edgeEvents = [];
    this.prevVx = 0;
    this.prevVy = 0;
    this.maxSamples = 100;
  }

  update(px, py, vx, vy, gameTime, w, h) {
    const speed = Math.sqrt(vx * vx + vy * vy);
    this.speedSamples.push({ speed, time: gameTime });
    if (this.speedSamples.length > this.maxSamples) this.speedSamples.shift();

    if (this.prevVx !== 0 || this.prevVy !== 0) {
      const prevSpeed = Math.sqrt(this.prevVx * this.prevVx + this.prevVy * this.prevVy);
      if (speed > 2 && prevSpeed > 2) {
        const dot = vx * this.prevVx + vy * this.prevVy;
        const normalized = dot / (speed * prevSpeed);
        if (normalized < -0.3) {
          this.reversals.push({ time: gameTime, x: px, y: py, angle: Math.atan2(vy, vx) });
          if (this.reversals.length > 30) this.reversals.shift();
        }
      }
    }
    this.prevVx = vx;
    this.prevVy = vy;

    const margin = 40;
    const edges = [];
    if (px < margin) edges.push('left');
    if (px > w - margin) edges.push('right');
    if (py < margin) edges.push('top');
    if (py > h - margin) edges.push('bottom');
    if (edges.length > 0) {
      this.edgeEvents.push({ time: gameTime, edge: edges.join('-') });
      if (this.edgeEvents.length > 50) this.edgeEvents.shift();
    }
  }

  getActivePattern(gameTime) {
    const recentReversals = this.reversals.filter(r => gameTime - r.time < 15);
    if (recentReversals.length >= 5) {
      const avgAngle = Math.atan2(
        recentReversals.reduce((s, r) => s + Math.sin(r.angle), 0) / recentReversals.length,
        recentReversals.reduce((s, r) => s + Math.cos(r.angle), 0) / recentReversals.length
      );
      return {
        type: 'panic-reversal',
        frequency: recentReversals.length,
        dominantAngle: avgAngle,
        confidence: Math.min(1, recentReversals.length / 10),
        description: 'Panic reversal detected',
      };
    }

    const recentEdges = this.edgeEvents.filter(e => gameTime - e.time < 20);
    if (recentEdges.length >= 10) {
      const edgeCounts = {};
      for (const e of recentEdges) {
        edgeCounts[e.edge] = (edgeCounts[e.edge] || 0) + 1;
      }
      const topEdge = Object.entries(edgeCounts).sort((a, b) => b[1] - a[1])[0];
      return {
        type: 'cornering',
        edge: topEdge[0],
        frequency: topEdge[1],
        confidence: Math.min(1, topEdge[1] / 15),
        description: `Cornering tendency: ${topEdge[0]}`,
      };
    }

    if (this.speedSamples.length > 30) {
      const recent = this.speedSamples.filter(s => gameTime - s.time < 10);
      const older = this.speedSamples.filter(s => gameTime - s.time >= 10 && gameTime - s.time < 20);
      if (recent.length > 5 && older.length > 5) {
        const recentAvg = recent.reduce((s, r) => s + r.speed, 0) / recent.length;
        const olderAvg = older.reduce((s, r) => s + r.speed, 0) / older.length;
        if (olderAvg > 1 && recentAvg < olderAvg * 0.6) {
          return {
            type: 'speed-freeze',
            recentSpeed: recentAvg,
            previousSpeed: olderAvg,
            confidence: 0.7,
            description: 'Speed drop under pressure',
          };
        }
      }
    }

    return null;
  }

  serialize() {
    return {
      avgReversalFreq: this.reversals.length,
      cornerPreference: this.edgeEvents.length > 0 ? this.edgeEvents[this.edgeEvents.length - 1].edge : null,
    };
  }
  deserialize(data) {}
}

// ============================================================
// AI Brain
// ============================================================
class AIBrain {
  constructor() {
    this.dodgeDirections = [];
    this.positionLog = [];
    this.reactionSamples = [];
    this.directionBias = { left: 0, right: 0, up: 0, down: 0 };
    this.totalSamples = 0;
    this.lastPlayerPos = null;
    this.lastProjectileTime = 0;
    this.playerMovedSinceShot = false;
    this.zoneVisits = new Array(9).fill(0);
    this._savedProfile = null;
    this.directionDetector = new DirectionBiasDetector();
    this.safeZoneDetector = new SafeZoneDetector();
    this.dodgeSequenceDetector = new DodgeSequenceDetector();
    this.panicDetector = new PanicDetector();
    this.load();
  }

  reset() {
    this.positionLog = [];
    this.lastPlayerPos = null;
    this.lastProjectileTime = 0;
    this.playerMovedSinceShot = false;
    this.directionDetector = new DirectionBiasDetector();
    this.safeZoneDetector = new SafeZoneDetector();
    this.dodgeSequenceDetector = new DodgeSequenceDetector();
    this.panicDetector = new PanicDetector();
  }

  trackPosition(x, y, time, w, h) {
    this.positionLog.push({ x, y, time });
    if (this.positionLog.length > 150) this.positionLog.shift();
    const zx = Math.min(2, Math.floor((x / w) * 3));
    const zy = Math.min(2, Math.floor((y / h) * 3));
    this.zoneVisits[zy * 3 + zx]++;
    if (this.lastPlayerPos) {
      const dx = x - this.lastPlayerPos.x;
      const dy = y - this.lastPlayerPos.y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      if (dist > 3) {
        if (!this.playerMovedSinceShot && this.lastProjectileTime > 0) {
          const reactionMs = time - this.lastProjectileTime;
          if (reactionMs > 50 && reactionMs < 2000) {
            this.reactionSamples.push(reactionMs);
            if (this.reactionSamples.length > 30) this.reactionSamples.shift();
          }
          this.playerMovedSinceShot = true;
        }
        const angle = Math.atan2(dy, dx);
        if (angle > -0.785 && angle <= 0.785) this.directionBias.right++;
        else if (angle > 0.785 && angle <= 2.356) this.directionBias.down++;
        else if (angle > -2.356 && angle <= -0.785) this.directionBias.up++;
        else this.directionBias.left++;
        this.totalSamples++;
        this.dodgeDirections.push({ dx: dx / dist, dy: dy / dist, time });
        if (this.dodgeDirections.length > 80) this.dodgeDirections.shift();
      }
      // Feed pattern detectors (time is in ms, detectors use seconds)
      const timeSec = time / 1000;
      this.directionDetector.update(dx, dy, timeSec);
      this.safeZoneDetector.update(x, y, timeSec, w, h);
      this.dodgeSequenceDetector.update(dx, dy, timeSec);
      this.panicDetector.update(x, y, dx, dy, timeSec, w, h);
    }
    this.lastPlayerPos = { x, y };
  }

  onProjectileFired(time) { this.lastProjectileTime = time; this.playerMovedSinceShot = false; }

  getAvgReaction() {
    if (this.reactionSamples.length < 3) return null;
    return Math.round(this.reactionSamples.reduce((a, b) => a + b, 0) / this.reactionSamples.length);
  }

  getDominantDodge() {
    const b = this.directionBias;
    const total = b.left + b.right + b.up + b.down;
    if (total < 8) return null;
    const entries = Object.entries(b);
    entries.sort((a, c) => c[1] - a[1]);
    return { direction: entries[0][0], pct: Math.round((entries[0][1] / total) * 100) };
  }

  getBiasPercentages() {
    const b = this.directionBias;
    const total = b.left + b.right + b.up + b.down || 1;
    return {
      up: Math.round((b.up / total) * 100),
      down: Math.round((b.down / total) * 100),
      left: Math.round((b.left / total) * 100),
      right: Math.round((b.right / total) * 100),
    };
  }

  getFavoriteZone(w, h) {
    let maxIdx = 0;
    for (let i = 1; i < 9; i++) if (this.zoneVisits[i] > this.zoneVisits[maxIdx]) maxIdx = i;
    const zx = maxIdx % 3;
    const zy = Math.floor(maxIdx / 3);
    return { x: (zx + 0.5) * (w / 3), y: (zy + 0.5) * (h / 3) };
  }

  getPredictedDodgeTarget(px, py, w, h) {
    const dom = this.getDominantDodge();
    if (!dom) return null;
    const offset = 100 + Math.random() * 60;
    switch (dom.direction) {
      case 'left':  return { x: Math.max(20, px - offset), y: py + (Math.random() - 0.5) * 40 };
      case 'right': return { x: Math.min(w - 20, px + offset), y: py + (Math.random() - 0.5) * 40 };
      case 'up':    return { x: px + (Math.random() - 0.5) * 40, y: Math.max(20, py - offset) };
      case 'down':  return { x: px + (Math.random() - 0.5) * 40, y: Math.min(h - 20, py + offset) };
    }
    return null;
  }

  getPredictedFuturePos(px, py, vx, vy, t) {
    return { x: px + vx * t, y: py + vy * t };
  }

  getConfidence() {
    const s = this.totalSamples;
    if (s < 5) return Math.round(s * 5);
    if (s < 30) return Math.round(25 + (s - 5) * 2);
    return Math.min(97, Math.round(75 + (s - 30) * 0.22));
  }

  getHighestConfidencePattern(gameTime) {
    const patterns = [
      this.directionDetector.getActivePattern(gameTime),
      this.safeZoneDetector.getActivePattern(gameTime),
      this.dodgeSequenceDetector.getActivePattern(gameTime),
      this.panicDetector.getActivePattern(gameTime),
    ].filter(Boolean);
    if (patterns.length === 0) return null;
    patterns.sort((a, b) => b.confidence - a.confidence);
    return patterns[0];
  }

  getActivePatternCount(gameTime) {
    return [
      this.directionDetector.getActivePattern(gameTime),
      this.safeZoneDetector.getActivePattern(gameTime),
      this.dodgeSequenceDetector.getActivePattern(gameTime),
      this.panicDetector.getActivePattern(gameTime),
    ].filter(Boolean).length;
  }

  getInsight() {
    const nowSec = Date.now() / 1000;
    const patterns = this.getActivePatternCount(nowSec);
    const dom = this.getDominantDodge();
    if (patterns === 0) return 'Scanning...';
    const parts = [];
    if (dom && dom.pct > 30) parts.push(`${dom.direction} ${dom.pct}%`);
    const safePattern = this.safeZoneDetector.getActivePattern(nowSec);
    if (safePattern) parts.push(`zone: ${safePattern.zoneName}`);
    const panicPattern = this.panicDetector.getActivePattern(nowSec);
    if (panicPattern) parts.push(panicPattern.type === 'panic-reversal' ? 'panic' : panicPattern.edge);
    return parts.length > 0 ? parts.join(' · ') : `${patterns} pattern${patterns > 1 ? 's' : ''}`;
  }

  save() {
    try {
      const existing = JSON.parse(localStorage.getItem('dodge-ai-brain')) || {};
      const sessionsPlayed = (existing.sessionsPlayed || 0) + 1;

      // Determine dominant patterns for welcome-back taunts
      const dominantPatterns = [];
      const dom = this.getDominantDodge();
      if (dom && dom.pct > 30) dominantPatterns.push(dom.direction + '-dodge');
      const favZoneIdx = this.zoneVisits.indexOf(Math.max(...this.zoneVisits));
      const zoneNames = ['top-left', 'top-center', 'top-right', 'mid-left', 'center', 'mid-right', 'bottom-left', 'bottom-center', 'bottom-right'];
      if (this.zoneVisits[favZoneIdx] > 20) dominantPatterns.push(zoneNames[favZoneIdx] + '-zone');

      localStorage.setItem('dodge-ai-brain', JSON.stringify({
        version: 2,
        directionBias: this.directionBias,
        totalSamples: this.totalSamples,
        reactionSamples: this.reactionSamples.slice(-20),
        zoneVisits: this.zoneVisits,
        sessionsPlayed: sessionsPlayed,
        lastPlayedAt: Date.now(),
        dominantPatterns: dominantPatterns.slice(0, 3),
        panicProfile: this.panicDetector.serialize(),
        dodgeSequenceSummary: this.dodgeSequenceDetector.serialize(),
        safeZoneSummary: this.safeZoneDetector.serialize(),
        directionSummary: this.directionDetector.serialize(),
        threatLevelHistory: [...(existing.threatLevelHistory || []).slice(-4), this.lastThreatLevel || 0].slice(-5),
      }));
    } catch (e) {}
  }

  load() {
    try {
      const data = JSON.parse(localStorage.getItem('dodge-ai-brain'));
      if (data) {
        this.directionBias = data.directionBias || this.directionBias;
        this.totalSamples = data.totalSamples || 0;
        this.reactionSamples = data.reactionSamples || [];
        this.zoneVisits = data.zoneVisits || new Array(9).fill(0);
        // Cross-session profile
        this._savedProfile = {
          sessionsPlayed: data.sessionsPlayed || 0,
          lastPlayedAt: data.lastPlayedAt || 0,
          dominantPatterns: data.dominantPatterns || [],
        };
      }
    } catch (e) {}
  }

  getSavedProfile() {
    return this._savedProfile || null;
  }
}

// ============================================================
// Particle
// ============================================================
class Particle {
  constructor(x, y, vx, vy, life, color, radius) {
    this.x = x; this.y = y; this.vx = vx; this.vy = vy;
    this.life = life; this.maxLife = life; this.color = color; this.radius = radius;
  }
  update(dt) {
    this.x += this.vx * dt; this.y += this.vy * dt;
    this.vx *= 0.97; this.vy *= 0.97; this.life -= dt;
  }
  draw(ctx) {
    ctx.globalAlpha = Math.max(0, this.life / this.maxLife) * 0.8;
    ctx.fillStyle = this.color;
    ctx.beginPath();
    ctx.arc(this.x, this.y, Math.max(0, this.radius * (this.life / this.maxLife)), 0, Math.PI * 2);
    ctx.fill();
    ctx.globalAlpha = 1;
  }
}

// ============================================================
// Shape Drawing Helper
// ============================================================
function drawShape(ctx, x, y, radius, shape, angle) {
  switch (shape) {
    case 'circle':
      ctx.arc(x, y, radius, 0, Math.PI * 2);
      break;
    case 'diamond': {
      const a = angle || 0;
      const c = Math.cos(a), s = Math.sin(a);
      const pts = [{x:0,y:-radius},{x:radius,y:0},{x:0,y:radius},{x:-radius,y:0}];
      for (let i = 0; i < pts.length; i++) {
        const px = x + pts[i].x * c - pts[i].y * s;
        const py = y + pts[i].x * s + pts[i].y * c;
        i === 0 ? ctx.moveTo(px, py) : ctx.lineTo(px, py);
      }
      ctx.closePath();
      break;
    }
    case 'triangle': {
      const a = angle || 0;
      const c = Math.cos(a), s = Math.sin(a);
      const pts = [{x:radius*1.2,y:0},{x:-radius*0.7,y:-radius*0.8},{x:-radius*0.7,y:radius*0.8}];
      for (let i = 0; i < pts.length; i++) {
        const px = x + pts[i].x * c - pts[i].y * s;
        const py = y + pts[i].x * s + pts[i].y * c;
        i === 0 ? ctx.moveTo(px, py) : ctx.lineTo(px, py);
      }
      ctx.closePath();
      break;
    }
    case 'hexagon': {
      const a = angle || 0;
      for (let i = 0; i < 6; i++) {
        const ha = (i / 6) * Math.PI * 2 + a;
        const px = x + Math.cos(ha) * radius;
        const py = y + Math.sin(ha) * radius;
        i === 0 ? ctx.moveTo(px, py) : ctx.lineTo(px, py);
      }
      ctx.closePath();
      break;
    }
    case 'arrow': {
      const a = angle || 0;
      const c = Math.cos(a), s = Math.sin(a);
      const pts = [{x:radius*1.3,y:0},{x:-radius*0.3,y:-radius*0.8},{x:0,y:0},{x:-radius*0.3,y:radius*0.8}];
      for (let i = 0; i < pts.length; i++) {
        const px = x + pts[i].x * c - pts[i].y * s;
        const py = y + pts[i].x * s + pts[i].y * c;
        i === 0 ? ctx.moveTo(px, py) : ctx.lineTo(px, py);
      }
      ctx.closePath();
      break;
    }
    case 'star': {
      const a = angle || 0;
      for (let i = 0; i < 10; i++) {
        const sa = (i / 10) * Math.PI * 2 - Math.PI / 2 + a;
        const r = i % 2 === 0 ? radius : radius * 0.45;
        const px = x + Math.cos(sa) * r;
        const py = y + Math.sin(sa) * r;
        i === 0 ? ctx.moveTo(px, py) : ctx.lineTo(px, py);
      }
      ctx.closePath();
      break;
    }
    case 'spiralShape': {
      // 3-arm swirl glyph radiating from center
      const a = angle || 0;
      for (let arm = 0; arm < 3; arm++) {
        const baseA = a + (arm / 3) * Math.PI * 2;
        ctx.moveTo(x, y);
        for (let t = 0; t <= 1; t += 0.2) {
          const r = radius * t;
          const sa = baseA + t * 1.5;
          const px = x + Math.cos(sa) * r;
          const py = y + Math.sin(sa) * r;
          ctx.lineTo(px, py);
        }
      }
      break;
    }
    case 'clusterShape': {
      // Circle with outer ring (bomb/grenade look)
      ctx.arc(x, y, radius * 0.6, 0, Math.PI * 2);
      ctx.moveTo(x + radius, y);
      ctx.arc(x, y, radius, 0, Math.PI * 2);
      break;
    }
    case 'mineShape': {
      // Octagon with crosshair lines
      const a = angle || 0;
      for (let i = 0; i < 8; i++) {
        const oa = (i / 8) * Math.PI * 2 + a;
        const px = x + Math.cos(oa) * radius;
        const py = y + Math.sin(oa) * radius;
        i === 0 ? ctx.moveTo(px, py) : ctx.lineTo(px, py);
      }
      ctx.closePath();
      // Crosshair lines
      ctx.moveTo(x - radius * 0.7, y);
      ctx.lineTo(x + radius * 0.7, y);
      ctx.moveTo(x, y - radius * 0.7);
      ctx.lineTo(x, y + radius * 0.7);
      break;
    }
  }
}

// ============================================================
// Boss Type Definitions
// ============================================================
const BOSS_TYPES = [
  { name: 'Sentinel',    shape: 'circle',   color: '#ff3355', behavior: 'homing', special: 'none',    shootInterval: 0 },
  { name: 'Shatterer',   shape: 'triangle', color: '#ff6633', behavior: 'homing', special: 'scatter', shootInterval: 2 },
  { name: 'Pulsar',      shape: 'hexagon',  color: '#a855f7', behavior: 'orbit',  special: 'ring',    shootInterval: 3 },
  { name: 'Mr Wiggles',  shape: 'diamond',  color: '#10b981', behavior: 'snake',  special: 'trail',   shootInterval: 1.5 },
  { name: 'The Void',    shape: 'star',     color: '#f43f5e', behavior: 'homing', special: 'both',    shootInterval: 2.5 },
];

// ============================================================
// Shockwave (for EMP, dash, etc.)
// ============================================================
class Shockwave {
  constructor(x, y, maxRadius, color, life) {
    this.x = x; this.y = y;
    this.maxRadius = maxRadius;
    this.radius = 0;
    this.color = color;
    this.life = life;
    this.maxLife = life;
  }
  update(dt) {
    this.life -= dt;
    const t = 1 - (this.life / this.maxLife);
    this.radius = this.maxRadius * t;
  }
  draw(ctx) {
    const alpha = Math.max(0, this.life / this.maxLife);
    ctx.globalAlpha = alpha * 0.6;
    ctx.strokeStyle = this.color;
    ctx.lineWidth = 3 * alpha + 1;
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
    ctx.stroke();
    // Inner glow ring
    ctx.globalAlpha = alpha * 0.2;
    ctx.lineWidth = 12 * alpha;
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
    ctx.stroke();
    ctx.globalAlpha = 1;
    ctx.lineWidth = 1;
  }
  isDead() { return this.life <= 0; }
}

// ============================================================
// Projectile — supports normal, splitter, bouncer, wave, accel, spiral, cluster, mine
// ============================================================
class Projectile {
  constructor(x, y, vx, vy, color, opts = {}) {
    this.x = x; this.y = y; this.vx = vx; this.vy = vy;
    this.color = color;
    this.radius = opts.radius || PROJECTILE_RADIUS;
    this.trail = [];
    this.age = 0;
    this.homing = opts.homing || false;
    this.homingStrength = 0.015;
    // Special types
    this.type = opts.type || 'normal'; // normal, splitter, bouncer, wave, accel, spiral, cluster, mine
    this.hasSplit = false;
    this.bounces = 0;
    this.maxBounces = 1;
    this.waveAmplitude = 30;
    this.waveFreq = 3;
    this.baseVx = vx; this.baseVy = vy;
    this.accelRate = opts.accelRate || 1.5; // multiplier per second
    this.splitChildren = opts.splitChildren || false; // true = this is a child from a split
    // Spiral properties
    this.spiralAngle = 0;
    this.spiralSpeed = opts.spiralSpeed || 6;   // radians/sec
    this.spiralRadius = opts.spiralRadius || 25; // pixel amplitude
    // Cluster properties
    this.fuseTime = opts.fuseTime || 1.0;
    this.hasExploded = false;
    // Mine properties
    this.travelTime = opts.travelTime || 0.5;
    this.dwellTime = opts.dwellTime || 2.5;
    this.hasDetonated = false;
  }

  update(dt, playerX, playerY, slowMod) {
    this.trail.push({ x: this.x, y: this.y });
    if (this.trail.length > 8) this.trail.shift();
    const speed = slowMod;

    // Homing
    if (this.homing && this.age < 3) {
      const dx = playerX - this.x;
      const dy = playerY - this.y;
      const dist = Math.sqrt(dx * dx + dy * dy) || 1;
      this.vx += (dx / dist) * this.homingStrength * 60 * dt;
      this.vy += (dy / dist) * this.homingStrength * 60 * dt;
      const currentSpeed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
      if (currentSpeed > 0) {
        const cap = 7;
        this.vx = (this.vx / currentSpeed) * Math.min(currentSpeed, cap);
        this.vy = (this.vy / currentSpeed) * Math.min(currentSpeed, cap);
      }
    }

    // Wave: oscillate perpendicular to travel direction
    if (this.type === 'wave') {
      const dir = Math.atan2(this.baseVy, this.baseVx);
      const perpX = -Math.sin(dir);
      const perpY = Math.cos(dir);
      const wave = Math.sin(this.age * this.waveFreq * Math.PI * 2) * this.waveAmplitude * dt * 4;
      this.x += this.baseVx * dt * 60 * speed + perpX * wave;
      this.y += this.baseVy * dt * 60 * speed + perpY * wave;
    }
    // Accel: speed increases over time
    else if (this.type === 'accel') {
      const mult = 1 + this.age * this.accelRate;
      this.x += this.vx * dt * 60 * speed * mult;
      this.y += this.vy * dt * 60 * speed * mult;
    }
    // Spiral: corkscrew oscillation perpendicular to travel direction
    else if (this.type === 'spiral') {
      this.spiralAngle += this.spiralSpeed * dt;
      const baseAngle = Math.atan2(this.baseVy, this.baseVx);
      const perpX = -Math.sin(baseAngle);
      const perpY = Math.cos(baseAngle);
      const orbit = Math.sin(this.spiralAngle) * this.spiralRadius;
      this.x += this.baseVx * dt * 60 * speed + perpX * orbit * dt * 4;
      this.y += this.baseVy * dt * 60 * speed + perpY * orbit * dt * 4;
    }
    // Cluster: travels straight, explodes after fuseTime (handled in checkCluster)
    else if (this.type === 'cluster') {
      this.x += this.vx * dt * 60 * speed;
      this.y += this.vy * dt * 60 * speed;
    }
    // Mine: slow travel, then dwell in place, then detonate (handled in checkMineDetonate)
    else if (this.type === 'mine') {
      if (this.age < this.travelTime) {
        this.x += this.vx * dt * 60 * speed * 0.3;
        this.y += this.vy * dt * 60 * speed * 0.3;
      }
      // dwell phase: sits in place (no movement)
      // detonation is handled in checkMineDetonate()
    }
    // Default movement
    else {
      this.x += this.vx * dt * 60 * speed;
      this.y += this.vy * dt * 60 * speed;
    }

    this.age += dt;
  }

  // Returns array of child projectiles if this should split
  checkSplit(w, h) {
    if (this.type !== 'splitter' || this.hasSplit || this.splitChildren) return null;
    // Split at ~40-60% of screen traverse
    if (this.age > 0.6 + Math.random() * 0.4) {
      this.hasSplit = true;
      const angle = Math.atan2(this.vy, this.vx);
      const speed = Math.sqrt(this.vx * this.vx + this.vy * this.vy) * 1.1;
      const spread = 0.4 + Math.random() * 0.3;
      const children = [];
      for (let i = -1; i <= 1; i += 2) {
        const a = angle + spread * i;
        children.push(new Projectile(this.x, this.y,
          Math.cos(a) * speed, Math.sin(a) * speed,
          '#ff69b4', { radius: 3.5, type: 'normal', splitChildren: true }
        ));
      }
      return children;
    }
    return null;
  }

  // Returns true if bounced
  checkBounce(w, h) {
    if (this.type !== 'bouncer' || this.bounces >= this.maxBounces) return false;
    let bounced = false;
    if (this.x <= 0 || this.x >= w) { this.vx *= -1; bounced = true; }
    if (this.y <= 0 || this.y >= h) { this.vy *= -1; bounced = true; }
    if (bounced) {
      this.bounces++;
      this.x = Math.max(1, Math.min(w - 1, this.x));
      this.y = Math.max(1, Math.min(h - 1, this.y));
    }
    return bounced;
  }

  // Returns array of child projectiles when cluster fuse expires (6-bullet ring)
  checkCluster() {
    if (this.type !== 'cluster' || this.hasExploded) return null;
    if (this.age > this.fuseTime) {
      this.hasExploded = true;
      const children = [];
      const count = 6;
      const childSpeed = Math.sqrt(this.vx * this.vx + this.vy * this.vy) * 0.8;
      for (let i = 0; i < count; i++) {
        const a = (i / count) * Math.PI * 2;
        children.push(new Projectile(this.x, this.y,
          Math.cos(a) * childSpeed, Math.sin(a) * childSpeed,
          '#ff8800', { radius: 3, type: 'normal', splitChildren: true }
        ));
      }
      return children;
    }
    return null;
  }

  // Returns array of child projectiles when mine detonates toward player (4 aimed bullets)
  checkMineDetonate(playerX, playerY) {
    if (this.type !== 'mine' || this.hasDetonated) return null;
    if (this.age > this.travelTime + this.dwellTime) {
      this.hasDetonated = true;
      const children = [];
      const count = 4;
      const dx = playerX - this.x;
      const dy = playerY - this.y;
      const dist = Math.sqrt(dx * dx + dy * dy) || 1;
      const baseSpeed = 5;
      const spread = 0.3;
      for (let i = 0; i < count; i++) {
        const angle = Math.atan2(dy, dx) + (i - 1.5) * spread;
        children.push(new Projectile(this.x, this.y,
          Math.cos(angle) * baseSpeed, Math.sin(angle) * baseSpeed,
          '#ff0066', { radius: 3, type: 'normal', splitChildren: true }
        ));
      }
      return children;
    }
    return null;
  }

  draw(ctx) {
    const angle = Math.atan2(this.vy, this.vx);

    // Determine shape
    let shape = 'circle';
    if (this.homing && this.type === 'normal') shape = 'star';
    else if (this.type === 'splitter') shape = 'diamond';
    else if (this.type === 'bouncer') shape = 'triangle';
    else if (this.type === 'wave') shape = 'hexagon';
    else if (this.type === 'accel') shape = 'arrow';
    else if (this.type === 'spiral') shape = 'spiralShape';
    else if (this.type === 'cluster') shape = 'clusterShape';
    else if (this.type === 'mine') shape = 'mineShape';
    if (this.splitChildren) shape = 'triangle';

    // Trail
    for (let i = 0; i < this.trail.length; i++) {
      const t = this.trail[i];
      const alpha = (i / this.trail.length) * 0.25;
      ctx.globalAlpha = alpha;
      ctx.fillStyle = this.color;
      ctx.beginPath();
      ctx.arc(t.x, t.y, this.radius * (i / this.trail.length), 0, Math.PI * 2);
      ctx.fill();
    }

    // Main body — shaped
    ctx.globalAlpha = 1;
    ctx.shadowColor = this.color;
    ctx.shadowBlur = this.homing ? 18 : 10;
    ctx.fillStyle = this.color;
    ctx.beginPath();
    const drawAngle = this.type === 'spiral' ? this.spiralAngle : angle;
    drawShape(ctx, this.x, this.y, this.radius, shape, drawAngle);
    ctx.fill();

    // Type-specific effects
    if (this.homing && this.age < 3) {
      ctx.strokeStyle = this.color;
      ctx.lineWidth = 1;
      ctx.globalAlpha = 0.4;
      ctx.beginPath();
      ctx.arc(this.x, this.y, this.radius + 4 + Math.sin(this.age * 8) * 2, 0, Math.PI * 2);
      ctx.stroke();
    }
    if (this.type === 'splitter' && !this.hasSplit) {
      ctx.globalAlpha = 0.5;
      ctx.strokeStyle = '#ff69b4';
      ctx.lineWidth = 1;
      const s = this.radius + 3;
      ctx.beginPath();
      ctx.moveTo(this.x - s, this.y); ctx.lineTo(this.x + s, this.y);
      ctx.moveTo(this.x, this.y - s); ctx.lineTo(this.x, this.y + s);
      ctx.stroke();
    }
    if (this.type === 'bouncer') {
      ctx.globalAlpha = 0.4;
      ctx.strokeStyle = '#00ff88';
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.arc(this.x, this.y, this.radius + 3, 0, Math.PI * 2);
      ctx.stroke();
    }
    if (this.type === 'wave') {
      ctx.globalAlpha = 0.2;
      ctx.fillStyle = '#a78bfa';
      ctx.beginPath();
      drawShape(ctx, this.x, this.y, this.radius + 2, 'hexagon', angle);
      ctx.fill();
    }
    if (this.type === 'accel') {
      const mult = 1 + this.age * this.accelRate;
      ctx.globalAlpha = Math.min(0.5, mult * 0.1);
      ctx.fillStyle = '#ff4400';
      ctx.beginPath();
      ctx.arc(this.x, this.y, this.radius + mult * 1.5, 0, Math.PI * 2);
      ctx.fill();
    }
    if (this.type === 'spiral') {
      // Trailing swirl effect
      ctx.globalAlpha = 0.25;
      ctx.strokeStyle = '#00ffaa';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.arc(this.x, this.y, this.radius + 3 + Math.sin(this.spiralAngle) * 2, 0, Math.PI * 2);
      ctx.stroke();
    }
    if (this.type === 'cluster' && !this.hasExploded) {
      // Pulse as fuse approaches: scale up in last 0.3s
      const fuseProgress = this.age / this.fuseTime;
      if (fuseProgress > 0.7) {
        const pulse = 1 + (fuseProgress - 0.7) / 0.3 * 0.5;
        ctx.globalAlpha = 0.4 * pulse;
        ctx.fillStyle = '#ff8800';
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius * pulse + 2, 0, Math.PI * 2);
        ctx.fill();
      }
    }
    if (this.type === 'mine' && !this.hasDetonated) {
      // During dwell phase: pulsing glow telegraph with increasing intensity
      if (this.age >= this.travelTime) {
        const dwellProgress = (this.age - this.travelTime) / this.dwellTime;
        const intensity = 0.3 + Math.sin(this.age * 4) * 0.3;
        const pulseRadius = this.radius + 4 + dwellProgress * 6;
        ctx.globalAlpha = intensity * (0.5 + dwellProgress * 0.5);
        ctx.strokeStyle = '#ff0066';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(this.x, this.y, pulseRadius, 0, Math.PI * 2);
        ctx.stroke();
        // Inner danger glow
        ctx.globalAlpha = intensity * 0.3;
        ctx.fillStyle = '#ff0066';
        ctx.beginPath();
        ctx.arc(this.x, this.y, pulseRadius * 0.8, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    // Counter-pattern purple glow overlay
    if (this.isCounter) {
      ctx.globalAlpha = 0.35;
      ctx.shadowColor = '#8b5cf6';
      ctx.shadowBlur = 12;
      ctx.strokeStyle = '#8b5cf6';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(this.x, this.y, this.radius + 5, 0, Math.PI * 2);
      ctx.stroke();
    }

    ctx.globalAlpha = 1;
    ctx.shadowBlur = 0;
  }

  isOffscreen(w, h) {
    const margin = 80;
    return this.x < -margin || this.x > w + margin || this.y < -margin || this.y > h + margin;
  }
}

// ============================================================
// Boss — Unique types per level
// ============================================================
class Boss {
  constructor(x, y, w, h, level) {
    this.x = x; this.y = y;
    this.w = w; this.h = h;
    this.level = level;
    this.bossType = BOSS_TYPES[(level - 1) % BOSS_TYPES.length];
    this.radius = 22 + level * 3;
    this.speed = 1.2 + level * 0.2;
    this.hp = 3;
    this.maxHp = 3;
    this.age = 0;
    this.lifetime = BOSS_LIFETIME;
    this.color = this.bossType.color;
    this.trail = [];
    this.pulsePhase = 0;
    this.rotationAngle = 0;
    this.shootTimer = this.bossType.shootInterval > 0 ? this.bossType.shootInterval : Infinity;
    this.pendingProjectiles = [];

    // Serpent segments
    this.segments = [];
    this.posHistory = [];
    if (this.bossType.behavior === 'snake') {
      for (let si = 0; si < 4; si++) this.segments.push({ x: x, y: y });
    }
    this.trailSegments = [];
    this.speedBurstTimer = 0;
    this.speedBurstActive = false;
    this.speedBurstDuration = 0;

    // Pulsar orbit
    this.orbitAngle = Math.random() * Math.PI * 2;
    this.orbitDist = 150;
  }

  update(dt, playerX, playerY) {
    this.age += dt;
    this.pulsePhase += dt * 3;
    this.rotationAngle += dt * 2;
    this.pendingProjectiles = [];

    if (this.bossType.behavior === 'orbit') {
      // Circular orbit around player
      this.orbitAngle += dt * 1.5;
      const targetX = playerX + Math.cos(this.orbitAngle) * this.orbitDist;
      const targetY = playerY + Math.sin(this.orbitAngle) * this.orbitDist;
      this.x += (targetX - this.x) * 0.03 * 60 * dt;
      this.y += (targetY - this.y) * 0.03 * 60 * dt;
    } else if (this.bossType.behavior === 'snake') {
      // Snake with wave motion + speed burst
      const dx = playerX - this.x;
      const dy = playerY - this.y;
      const dist = Math.sqrt(dx * dx + dy * dy) || 1;
      const perpX = -dy / dist;
      const perpY = dx / dist;
      const wave = Math.sin(this.age * 3) * 50 * dt;

      // Speed burst every 4 seconds
      this.speedBurstTimer += dt;
      if (this.speedBurstTimer >= 4 && !this.speedBurstActive) {
        this.speedBurstActive = true;
        this.speedBurstDuration = 0.5;
        this.speedBurstTimer = 0;
      }
      let speedMult = 1;
      if (this.speedBurstActive) {
        speedMult = 2;
        this.speedBurstDuration -= dt;
        if (this.speedBurstDuration <= 0) this.speedBurstActive = false;
      }

      this.x += (dx / dist) * this.speed * speedMult * dt * 60 + perpX * wave;
      this.y += (dy / dist) * this.speed * speedMult * dt * 60 + perpY * wave;

      // Toxic trail: leave behind poison segments
      if (this.bossType.special === 'trail' && Math.random() < dt * 3) {
        this.trailSegments.push({ x: this.x, y: this.y, age: 0, maxAge: 3 });
      }
    } else {
      // Homing toward player
      const dx = playerX - this.x;
      const dy = playerY - this.y;
      const dist = Math.sqrt(dx * dx + dy * dy) || 1;
      this.x += (dx / dist) * this.speed * dt * 60;
      this.y += (dy / dist) * this.speed * dt * 60;
    }

    // Clamp to screen
    this.x = Math.max(this.radius, Math.min(this.w - this.radius, this.x));
    this.y = Math.max(this.radius, Math.min(this.h - this.radius, this.y));

    this.trail.push({ x: this.x, y: this.y });
    if (this.trail.length > 20) this.trail.shift();

    // Serpent segment tracking
    if (this.bossType.behavior === 'snake') {
      this.posHistory.push({ x: this.x, y: this.y });
      if (this.posHistory.length > 80) this.posHistory.shift();
      if (this.posHistory.length > 5) {
        for (let i = 0; i < this.segments.length; i++) {
          const histIdx = Math.max(0, this.posHistory.length - 1 - (i + 1) * 10);
          this.segments[i].x = this.posHistory[histIdx].x;
          this.segments[i].y = this.posHistory[histIdx].y;
        }
      }
    }

    // Update trail segments
    for (let ti = this.trailSegments.length - 1; ti >= 0; ti--) {
      this.trailSegments[ti].age += dt;
      if (this.trailSegments[ti].age > this.trailSegments[ti].maxAge) {
        this.trailSegments.splice(ti, 1);
      }
    }

    // Shooting
    if (this.bossType.shootInterval > 0) {
      this.shootTimer -= dt;
      if (this.shootTimer <= 0) {
        this.shootTimer = this.bossType.shootInterval;
        this.shoot(playerX, playerY);
      }
    }
  }

  shoot(playerX, playerY) {
    const special = this.bossType.special;

    if (special === 'scatter' || special === 'both') {
      const count = 3 + Math.floor(Math.random() * 3);
      const baseAngle = Math.atan2(playerY - this.y, playerX - this.x);
      const spread = 0.3;
      for (let i = 0; i < count; i++) {
        const a = baseAngle + (i - (count - 1) / 2) * spread;
        const spd = 3.5 + this.level * 0.3;
        this.pendingProjectiles.push(new Projectile(
          this.x, this.y, Math.cos(a) * spd, Math.sin(a) * spd,
          this.color, { type: 'splitter', radius: 4 }
        ));
      }
    }

    if (special === 'trail') {
      // Spit attack: fire homing projectiles from head and segments
      const sources = [{ x: this.x, y: this.y }, ...this.segments.slice(0, 2)];
      for (const src of sources) {
        const a = Math.atan2(playerY - src.y, playerX - src.x);
        const spd = 3 + this.level * 0.2;
        this.pendingProjectiles.push(new Projectile(
          src.x, src.y, Math.cos(a) * spd, Math.sin(a) * spd,
          '#10b981', { type: 'normal', radius: 3, homing: true }
        ));
      }
    }

    if (special === 'ring' || special === 'both') {
      for (let i = 0; i < 8; i++) {
        const a = (i / 8) * Math.PI * 2;
        this.pendingProjectiles.push(new Projectile(
          this.x, this.y, Math.cos(a) * 4, Math.sin(a) * 4,
          this.color, { type: 'normal', radius: 3.5 }
        ));
      }
    }
  }

  hit() {
    this.hp--;
    return this.hp <= 0;
  }

  isExpired() {
    // Sentinel stays alive — it's a persistent threat, not a timer
    if (this.bossType.name === 'Sentinel') return false;
    return this.age > this.lifetime;
  }

  getCollisionPoints() {
    const points = [{ x: this.x, y: this.y, radius: this.radius }];
    if (this.bossType.behavior === 'snake') {
      for (let i = 0; i < this.segments.length; i++) {
        points.push({ x: this.segments[i].x, y: this.segments[i].y, radius: this.radius * (0.7 - i * 0.15) });
      }
    }
    return points;
  }

  draw(ctx) {
    const pulse = Math.sin(this.pulsePhase) * 0.2 + 0.8;

    // Trail
    for (let i = 0; i < this.trail.length; i++) {
      const t = this.trail[i];
      ctx.globalAlpha = (i / this.trail.length) * 0.15;
      ctx.fillStyle = this.color;
      const trailR = this.radius * (i / this.trail.length) * 0.8;
      ctx.beginPath();
      drawShape(ctx, t.x, t.y, trailR, this.bossType.shape, this.rotationAngle);
      ctx.fill();
    }

    // Serpent segments
    if (this.bossType.behavior === 'snake') {
      for (let i = 0; i < this.segments.length; i++) {
        const seg = this.segments[i];
        const segR = this.radius * (0.7 - i * 0.15);
        ctx.globalAlpha = 0.7 - i * 0.15;
        ctx.shadowColor = this.color;
        ctx.shadowBlur = 20 * pulse;
        ctx.fillStyle = this.color;
        ctx.beginPath();
        drawShape(ctx, seg.x, seg.y, segR * pulse, 'diamond', this.rotationAngle + i * 0.5);
        ctx.fill();
        ctx.shadowBlur = 0;
      }
    }

    // Toxic trail segments
    if (this.trailSegments) {
      for (const ts of this.trailSegments) {
        const tAlpha = 0.4 * (1 - ts.age / ts.maxAge);
        ctx.globalAlpha = tAlpha;
        ctx.fillStyle = '#10b981';
        ctx.shadowColor = '#10b981';
        ctx.shadowBlur = 8;
        ctx.beginPath();
        ctx.arc(ts.x, ts.y, 6 * (1 - ts.age / ts.maxAge * 0.3), 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;
      }
    }

    // Outer danger glow
    ctx.globalAlpha = 0.1 * pulse;
    ctx.fillStyle = this.color;
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.radius + 20 * pulse, 0, Math.PI * 2);
    ctx.fill();

    // Main body — shaped
    ctx.globalAlpha = 0.9;
    ctx.shadowColor = this.color;
    ctx.shadowBlur = 30 * pulse;
    ctx.fillStyle = this.color;
    ctx.beginPath();
    drawShape(ctx, this.x, this.y, this.radius * pulse, this.bossType.shape, this.rotationAngle);
    ctx.fill();

    // Inner core
    ctx.shadowBlur = 0;
    ctx.fillStyle = '#fff';
    ctx.globalAlpha = 0.4 * pulse;
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.radius * 0.4, 0, Math.PI * 2);
    ctx.fill();

    // HP indicator — arcs
    ctx.globalAlpha = 0.8;
    ctx.strokeStyle = '#fff';
    ctx.lineWidth = 2;
    for (let i = 0; i < this.hp; i++) {
      const startAngle = (i / this.maxHp) * Math.PI * 2 - Math.PI / 2;
      const endAngle = ((i + 0.7) / this.maxHp) * Math.PI * 2 - Math.PI / 2;
      ctx.beginPath();
      ctx.arc(this.x, this.y, this.radius + 6, startAngle, endAngle);
      ctx.stroke();
    }

    // Boss name label
    ctx.globalAlpha = 0.6;
    ctx.fillStyle = this.color;
    ctx.font = 'bold 9px Courier New';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(this.bossType.name.toUpperCase(), this.x, this.y - this.radius - 12);

    // Lifetime bar (skip for persistent bosses like Sentinel)
    if (this.bossType.name !== 'Sentinel') {
      const lifeRatio = Math.max(0, 1 - this.age / this.lifetime);
      ctx.globalAlpha = 0.5;
      ctx.fillStyle = '#333';
      ctx.fillRect(this.x - 20, this.y + this.radius + 12, 40, 3);
      ctx.fillStyle = this.color;
      ctx.fillRect(this.x - 20, this.y + this.radius + 12, 40 * lifeRatio, 3);
    }

    ctx.globalAlpha = 1;
    ctx.shadowBlur = 0;
  }
}

// ============================================================
// Warning
// ============================================================
class Warning {
  constructor(x, y, time) {
    this.x = x; this.y = y; this.time = time;
  }
  isExpired(now) { return now - this.time > WARNING_DURATION; }
  draw(ctx, now) {
    const progress = Math.max(0, Math.min(1, (now - this.time) / WARNING_DURATION));
    ctx.globalAlpha = (1 - progress) * 0.6;
    ctx.strokeStyle = '#ff3355';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(this.x, this.y, 8 + progress * 12, 0, Math.PI * 2);
    ctx.stroke();
    ctx.globalAlpha = 1;
  }
}

// ============================================================
// PowerUp
// ============================================================
class PowerUp {
  constructor(x, y, type, time) {
    this.x = x; this.y = y; this.type = type;
    this.def = POWERUP_TYPES[type];
    this.spawnTime = time; this.age = 0;
  }
  update(dt) { this.age += dt; }
  isExpired() { return this.age > POWERUP_LIFETIME; }
  draw(ctx) {
    const pulse = Math.sin(this.age * 4) * 0.3 + 0.7;
    const fadeOut = this.age > POWERUP_LIFETIME - 1.5 ? Math.max(0, (POWERUP_LIFETIME - this.age) / 1.5) : 1;
    ctx.globalAlpha = 0.15 * pulse * fadeOut;
    ctx.fillStyle = this.def.color;
    ctx.beginPath();
    ctx.arc(this.x, this.y, POWERUP_RADIUS + 8 + Math.sin(this.age * 3) * 3, 0, Math.PI * 2);
    ctx.fill();
    ctx.globalAlpha = 0.9 * fadeOut;
    ctx.shadowColor = this.def.color;
    ctx.shadowBlur = 20 * pulse;
    ctx.fillStyle = this.def.color;
    ctx.beginPath();
    ctx.arc(this.x, this.y, POWERUP_RADIUS * pulse, 0, Math.PI * 2);
    ctx.fill();
    ctx.shadowBlur = 0;
    ctx.globalAlpha = fadeOut;
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 14px Courier New';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(this.def.icon, this.x, this.y + 1);
    ctx.globalAlpha = 1;
  }
}

// ============================================================
// Sound Engine — Symphonic Synthwave (Web Audio API)
// ============================================================
class SoundEngine {
  constructor() {
    this.ctx = null;
    this.muted = false;
    this.musicPlaying = false;
    this.musicBPM = 88;
    this.musicIntensity = 0;
    this._targetIntensity = 0;
    this._targetBPM = 88;
    this._beatTimer = null;
    this._initialized = false;
    this._measureCount = 0;
    this._chordIndex = -1;
    this._arpStep = 0;
    this._masterGain = null;
    this._compressor = null;
    this._reverb = null;
    this._reverbSend = null;
    // Cinematic minor progression: Cm -> Ab -> Eb -> Bb (i-VI-III-VII)
    this._chords = [
      { root: 65.41, notes: [65.41, 77.78, 98.00] },   // Cm: C2, Eb2, G2
      { root: 51.91, notes: [51.91, 65.41, 77.78] },   // Ab: Ab1, C2, Eb2
      { root: 77.78, notes: [77.78, 98.00, 116.54] },  // Eb: Eb2, G2, Bb2
      { root: 58.27, notes: [58.27, 73.42, 87.31] },   // Bb: Bb1, D2, F2
    ];
  }

  init() {
    if (this._initialized) return;
    try {
      this.ctx = new (window.AudioContext || window.webkitAudioContext)();
      // Master output chain: gain -> compressor -> destination
      this._compressor = this.ctx.createDynamicsCompressor();
      this._compressor.threshold.value = -18;
      this._compressor.knee.value = 12;
      this._compressor.ratio.value = 4;
      this._compressor.attack.value = 0.003;
      this._compressor.release.value = 0.15;
      this._compressor.connect(this.ctx.destination);
      this._masterGain = this.ctx.createGain();
      this._masterGain.gain.value = 0.75;
      this._masterGain.connect(this._compressor);
      // Reverb send (convolver with procedural impulse response)
      this._reverb = this._createReverb();
      this._reverbSend = this.ctx.createGain();
      this._reverbSend.gain.value = 0.2;
      this._reverbSend.connect(this._reverb);
      this._reverb.connect(this._masterGain);
      this._initialized = true;
    } catch (e) {}
  }

  _createReverb() {
    const len = this.ctx.sampleRate * 2;
    const impulse = this.ctx.createBuffer(2, len, this.ctx.sampleRate);
    for (let ch = 0; ch < 2; ch++) {
      const d = impulse.getChannelData(0);
      for (let i = 0; i < len; i++) {
        d[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / len, 2.5);
      }
    }
    const conv = this.ctx.createConvolver();
    conv.buffer = impulse;
    return conv;
  }

  _out() { return this._masterGain || this.ctx.destination; }

  resume() {
    if (this.ctx && this.ctx.state === 'suspended') this.ctx.resume();
  }

  toggleMute() {
    this.muted = !this.muted;
    if (this.muted) this.stopMusic();
    return this.muted;
  }

  // --- Background Music ---
  startMusic() {
    if (!this.ctx || this.musicPlaying || this.muted) return;
    this.musicPlaying = true;
    this._measureCount = 0;
    this._chordIndex = -1;
    this._arpStep = 0;
    this._scheduleMeasure();
  }

  stopMusic() {
    this.musicPlaying = false;
    if (this._beatTimer) { clearTimeout(this._beatTimer); this._beatTimer = null; }
  }

  updateMusicIntensity(phase, threatLevel) {
    if (!this.ctx) return;
    // Set targets — actual values lerp smoothly in _scheduleMeasure
    this._targetIntensity = Math.min(1, (phase / 5) * 0.6 + threatLevel * 0.4);
    this._targetBPM = 88 + this._targetIntensity * 72;
  }

  _scheduleMeasure() {
    if (!this.musicPlaying || this.muted) return;
    // Smooth lerp toward target intensity and BPM (15% per measure)
    const lr = 0.15;
    this.musicIntensity += (this._targetIntensity - this.musicIntensity) * lr;
    this.musicBPM += (this._targetBPM - this.musicBPM) * lr;
    const beatDur = 60 / this.musicBPM;
    const workaheadMs = 100;
    const measureDur = beatDur * 4;
    const now = this.ctx.currentTime + 0.05;
    const I = this.musicIntensity;
    // Smooth fade factor: 0 at threshold, 1 at threshold+0.1
    const fade = (threshold) => Math.max(0, Math.min(1, (I - threshold) / 0.1));
    // Advance chord every 2 measures
    if (this._measureCount % 2 === 0) {
      this._chordIndex = (this._chordIndex + 1) % this._chords.length;
    }
    const chord = this._chords[this._chordIndex];

    // === STRINGS PAD (always present — orchestral foundation) ===
    this._scheduleStringPad(chord.notes, now, measureDur + 0.05);

    // === DRUMS ===
    for (let beat = 0; beat < 4; beat++) {
      const bt = now + beat * beatDur;
      // Kick on 1 and 3
      if (beat === 0 || beat === 2) this._scheduleKick(bt);
      // Hi-hat on 2 and 4
      if (beat === 1 || beat === 3) this._scheduleHiHat(bt);
      // Eighth-note hi-hats fade in around I=0.4
      if (I > 0.35) this._scheduleHiHat(bt + beatDur / 2, fade(0.35) * 0.5);
      // Snare fades in around I=0.25
      if ((beat === 1 || beat === 3) && I > 0.2) this._scheduleSnare(bt, fade(0.2));
    }

    // === SUB BASS (fades in around I=0.15) ===
    if (I > 0.1) {
      const subFade = fade(0.1);
      this._scheduleSubBass(chord.root, now, beatDur * 2, subFade);
      this._scheduleSubBass(chord.root, now + beatDur * 2, beatDur * 2, subFade);
    }

    // === SYNTH BASS (fades in around I=0.35) ===
    if (I > 0.3) {
      const synthFade = fade(0.3);
      this._scheduleSynthBass(chord.root * 2, now, beatDur * 0.9, synthFade);
      this._scheduleSynthBass(chord.root * 2, now + beatDur * 2, beatDur * 0.45, synthFade);
      this._scheduleSynthBass(chord.root * 2, now + beatDur * 2.5, beatDur * 0.45, synthFade);
    }

    // === ARPEGGIATOR (fades in around I=0.45) ===
    if (I > 0.4) {
      const arpFade = fade(0.4);
      const arpNotes = chord.notes.map(f => f * 8); // octave 5
      const stepsPerBeat = I > 0.7 ? 4 : 2;
      const arpInterval = beatDur / stepsPerBeat;
      for (let beat = 0; beat < 4; beat++) {
        for (let sub = 0; sub < stepsPerBeat; sub++) {
          const at = now + beat * beatDur + sub * arpInterval;
          const noteIdx = this._arpStep % arpNotes.length;
          this._scheduleArpNote(arpNotes[noteIdx], at, arpInterval * 0.7, arpFade);
          this._arpStep++;
        }
      }
    }

    // === LEAD MELODY (fades in around I=0.65) ===
    if (I > 0.6) {
      this._scheduleLeadPhrase(chord.notes, now, measureDur, fade(0.6));
    }

    this._measureCount++;
    this._beatTimer = setTimeout(
      () => this._scheduleMeasure(),
      measureDur * 1000 - workaheadMs
    );
  }

  // --- Music Instruments ---

  _scheduleStringPad(notes, t, dur) {
    const I = this.musicIntensity;
    const vol = 0.025 + I * 0.015;
    const cutoff = 600 + I * 900;
    const attack = Math.max(0.1, 0.5 - I * 0.25);
    notes.forEach(freq => {
      // 3 detuned sawtooth oscillators per note = lush strings
      [-7, 0, 7].forEach(detune => {
        const osc = this.ctx.createOscillator();
        osc.type = 'sawtooth';
        osc.frequency.value = freq * 4; // octave 4 for strings
        osc.detune.value = detune + (Math.random() - 0.5) * 3;
        const lp = this.ctx.createBiquadFilter();
        lp.type = 'lowpass';
        lp.frequency.value = cutoff;
        lp.Q.value = 0.7;
        const g = this.ctx.createGain();
        g.gain.setValueAtTime(0, t);
        g.gain.linearRampToValueAtTime(vol, t + attack);
        g.gain.setValueAtTime(vol, t + dur - 0.2);
        g.gain.linearRampToValueAtTime(0, t + dur);
        osc.connect(lp);
        lp.connect(g);
        g.connect(this._out());
        // Reverb send for spaciousness
        const rs = this.ctx.createGain();
        rs.gain.value = 0.35;
        lp.connect(rs);
        rs.connect(this._reverbSend);
        osc.start(t);
        osc.stop(t + dur + 0.01);
      });
    });
  }

  _scheduleKick(t) {
    const osc = this.ctx.createOscillator();
    const g = this.ctx.createGain();
    osc.type = 'sine';
    osc.frequency.setValueAtTime(150, t);
    osc.frequency.exponentialRampToValueAtTime(35, t + 0.1);
    g.gain.setValueAtTime(0.3 + this.musicIntensity * 0.1, t);
    g.gain.exponentialRampToValueAtTime(0.001, t + 0.2);
    osc.connect(g);
    g.connect(this._out());
    osc.start(t);
    osc.stop(t + 0.2);
  }

  _scheduleHiHat(t, volScale = 1) {
    const bufSz = this.ctx.sampleRate * 0.04;
    const buf = this.ctx.createBuffer(1, bufSz, this.ctx.sampleRate);
    const d = buf.getChannelData(0);
    for (let i = 0; i < bufSz; i++) d[i] = Math.random() * 2 - 1;
    const src = this.ctx.createBufferSource();
    src.buffer = buf;
    const hp = this.ctx.createBiquadFilter();
    hp.type = 'highpass';
    hp.frequency.value = 8000;
    const g = this.ctx.createGain();
    g.gain.setValueAtTime((0.06 + this.musicIntensity * 0.04) * volScale, t);
    g.gain.exponentialRampToValueAtTime(0.001, t + 0.04);
    src.connect(hp);
    hp.connect(g);
    g.connect(this._out());
    src.start(t);
  }

  _scheduleSnare(t, fadeAmt = 1) {
    // Noise body
    const bufSz = this.ctx.sampleRate * 0.12;
    const buf = this.ctx.createBuffer(1, bufSz, this.ctx.sampleRate);
    const d = buf.getChannelData(0);
    for (let i = 0; i < bufSz; i++) d[i] = Math.random() * 2 - 1;
    const src = this.ctx.createBufferSource();
    src.buffer = buf;
    const bp = this.ctx.createBiquadFilter();
    bp.type = 'bandpass';
    bp.frequency.value = 3000;
    bp.Q.value = 0.8;
    const g = this.ctx.createGain();
    g.gain.setValueAtTime((0.1 + this.musicIntensity * 0.05) * fadeAmt, t);
    g.gain.exponentialRampToValueAtTime(0.001, t + 0.12);
    src.connect(bp);
    bp.connect(g);
    g.connect(this._out());
    src.start(t);
    // Tonal snap
    const osc = this.ctx.createOscillator();
    osc.type = 'triangle';
    osc.frequency.setValueAtTime(200, t);
    osc.frequency.exponentialRampToValueAtTime(100, t + 0.05);
    const g2 = this.ctx.createGain();
    g2.gain.setValueAtTime(0.08 * fadeAmt, t);
    g2.gain.exponentialRampToValueAtTime(0.001, t + 0.06);
    osc.connect(g2);
    g2.connect(this._out());
    osc.start(t);
    osc.stop(t + 0.06);
  }

  _scheduleSubBass(freq, t, dur, fadeAmt = 1) {
    const osc = this.ctx.createOscillator();
    osc.type = 'sine';
    osc.frequency.value = freq;
    const g = this.ctx.createGain();
    const vol = (0.14 + this.musicIntensity * 0.08) * fadeAmt;
    g.gain.setValueAtTime(0, t);
    g.gain.linearRampToValueAtTime(vol, t + 0.02);
    g.gain.setValueAtTime(vol, t + dur - 0.04);
    g.gain.linearRampToValueAtTime(0, t + dur);
    osc.connect(g);
    g.connect(this._out());
    osc.start(t);
    osc.stop(t + dur + 0.01);
  }

  _scheduleSynthBass(freq, t, dur, fadeAmt = 1) {
    const osc = this.ctx.createOscillator();
    osc.type = 'sawtooth';
    osc.frequency.value = freq;
    const lp = this.ctx.createBiquadFilter();
    lp.type = 'lowpass';
    lp.frequency.setValueAtTime(300 + this.musicIntensity * 600, t);
    lp.frequency.exponentialRampToValueAtTime(200, t + dur);
    lp.Q.value = 3;
    const g = this.ctx.createGain();
    g.gain.setValueAtTime((0.07 + this.musicIntensity * 0.04) * fadeAmt, t);
    g.gain.exponentialRampToValueAtTime(0.001, t + dur);
    osc.connect(lp);
    lp.connect(g);
    g.connect(this._out());
    osc.start(t);
    osc.stop(t + dur + 0.01);
  }

  _scheduleArpNote(freq, t, dur, fadeAmt = 1) {
    const osc = this.ctx.createOscillator();
    osc.type = 'square';
    osc.frequency.value = freq;
    const lp = this.ctx.createBiquadFilter();
    lp.type = 'lowpass';
    lp.frequency.value = 2000 + this.musicIntensity * 2000;
    lp.Q.value = 1;
    const g = this.ctx.createGain();
    const vol = (0.03 + this.musicIntensity * 0.015) * fadeAmt;
    g.gain.setValueAtTime(vol, t);
    g.gain.setValueAtTime(vol * 0.6, t + dur * 0.5);
    g.gain.linearRampToValueAtTime(0, t + dur);
    osc.connect(lp);
    lp.connect(g);
    g.connect(this._out());
    // Arp reverb send
    const rs = this.ctx.createGain();
    rs.gain.value = 0.25;
    lp.connect(rs);
    rs.connect(this._reverbSend);
    osc.start(t);
    osc.stop(t + dur + 0.01);
  }

  _scheduleLeadPhrase(chordNotes, startTime, measureDur, fadeAmt = 1) {
    const beatDur = measureDur / 4;
    const leadNotes = chordNotes.map(f => f * 8); // octave 5
    // Melodic pattern using chord tones (-1 = rest)
    const pattern = [0, -1, 2, 1, -1, 2, 0, 1];
    const noteLen = beatDur / 2;
    pattern.forEach((idx, i) => {
      if (idx === -1) return;
      const freq = leadNotes[idx % leadNotes.length];
      const t = startTime + i * noteLen;
      const osc = this.ctx.createOscillator();
      osc.type = 'triangle';
      osc.frequency.value = freq;
      const lp = this.ctx.createBiquadFilter();
      lp.type = 'lowpass';
      lp.frequency.value = 3000;
      const g = this.ctx.createGain();
      g.gain.setValueAtTime(0, t);
      g.gain.linearRampToValueAtTime(0.03 * fadeAmt, t + 0.02);
      g.gain.setValueAtTime(0.025 * fadeAmt, t + noteLen * 0.6);
      g.gain.linearRampToValueAtTime(0, t + noteLen * 0.9);
      osc.connect(lp);
      lp.connect(g);
      g.connect(this._out());
      // Lead reverb send
      const rs = this.ctx.createGain();
      rs.gain.value = 0.45;
      lp.connect(rs);
      rs.connect(this._reverbSend);
      osc.start(t);
      osc.stop(t + noteLen);
    });
  }

  // --- Sound Effects ---

  playCollect() {
    if (!this.ctx || this.muted) return;
    const t = this.ctx.currentTime;
    const osc = this.ctx.createOscillator();
    const g = this.ctx.createGain();
    osc.type = 'sine';
    osc.frequency.setValueAtTime(200, t);
    osc.frequency.exponentialRampToValueAtTime(800, t + 0.15);
    g.gain.setValueAtTime(0.2, t);
    g.gain.exponentialRampToValueAtTime(0.001, t + 0.15);
    osc.connect(g); g.connect(this._out());
    osc.start(t); osc.stop(t + 0.15);
  }

  playEMP() {
    if (!this.ctx || this.muted) return;
    const t = this.ctx.currentTime;
    const out = this._out();
    // Deep boom
    const osc = this.ctx.createOscillator();
    const g = this.ctx.createGain();
    osc.type = 'sine';
    osc.frequency.setValueAtTime(60, t);
    osc.frequency.exponentialRampToValueAtTime(20, t + 0.5);
    g.gain.setValueAtTime(0.5, t);
    g.gain.exponentialRampToValueAtTime(0.001, t + 0.5);
    osc.connect(g); g.connect(out);
    osc.start(t); osc.stop(t + 0.5);
    // Crackle
    const bufLen = this.ctx.sampleRate * 0.4;
    const buf = this.ctx.createBuffer(1, bufLen, this.ctx.sampleRate);
    const d = buf.getChannelData(0);
    for (let i = 0; i < bufLen; i++) d[i] = (Math.random() * 2 - 1) * Math.exp(-i / (bufLen * 0.15));
    const src = this.ctx.createBufferSource();
    src.buffer = buf;
    const g2 = this.ctx.createGain();
    g2.gain.setValueAtTime(0.25, t);
    g2.gain.exponentialRampToValueAtTime(0.001, t + 0.4);
    src.connect(g2); g2.connect(out);
    src.start(t);
  }

  playNearMiss() {
    if (!this.ctx || this.muted) return;
    const t = this.ctx.currentTime;
    const bufLen = this.ctx.sampleRate * 0.08;
    const buf = this.ctx.createBuffer(1, bufLen, this.ctx.sampleRate);
    const d = buf.getChannelData(0);
    for (let i = 0; i < bufLen; i++) d[i] = (Math.random() * 2 - 1) * (1 - i / bufLen);
    const src = this.ctx.createBufferSource();
    src.buffer = buf;
    const bp = this.ctx.createBiquadFilter();
    bp.type = 'bandpass'; bp.frequency.value = 2000; bp.Q.value = 2;
    const g = this.ctx.createGain();
    g.gain.setValueAtTime(0.12, t);
    g.gain.exponentialRampToValueAtTime(0.001, t + 0.08);
    src.connect(bp); bp.connect(g); g.connect(this._out());
    src.start(t);
  }

  playPhase() {
    // Epic orchestral level transition: timpani + rising strings + cymbal + chime
    if (!this.ctx || this.muted) return;
    const t = this.ctx.currentTime;
    const out = this._out();
    // 1. Timpani impact
    const timp = this.ctx.createOscillator();
    const timpG = this.ctx.createGain();
    timp.type = 'sine';
    timp.frequency.setValueAtTime(80, t);
    timp.frequency.exponentialRampToValueAtTime(45, t + 0.4);
    timpG.gain.setValueAtTime(0.35, t);
    timpG.gain.exponentialRampToValueAtTime(0.001, t + 0.5);
    timp.connect(timpG); timpG.connect(out);
    timp.start(t); timp.stop(t + 0.5);
    // 2. Rising strings swell (filtered sawtooth chord sweeping up)
    [130.81, 155.56, 196.00, 261.63].forEach(startFreq => {
      const osc = this.ctx.createOscillator();
      osc.type = 'sawtooth';
      osc.frequency.setValueAtTime(startFreq, t);
      osc.frequency.exponentialRampToValueAtTime(startFreq * 2, t + 0.8);
      const lp = this.ctx.createBiquadFilter();
      lp.type = 'lowpass';
      lp.frequency.setValueAtTime(300, t);
      lp.frequency.linearRampToValueAtTime(3000, t + 0.7);
      const g = this.ctx.createGain();
      g.gain.setValueAtTime(0, t);
      g.gain.linearRampToValueAtTime(0.05, t + 0.35);
      g.gain.setValueAtTime(0.05, t + 0.7);
      g.gain.exponentialRampToValueAtTime(0.001, t + 1.0);
      osc.connect(lp); lp.connect(g); g.connect(out);
      // Reverb for epic wash
      if (this._reverbSend) {
        const rs = this.ctx.createGain();
        rs.gain.value = 0.5;
        lp.connect(rs); rs.connect(this._reverbSend);
      }
      osc.start(t); osc.stop(t + 1.0);
    });
    // 3. Cymbal crash at the swell peak
    const crashLen = this.ctx.sampleRate * 0.8;
    const crashBuf = this.ctx.createBuffer(1, crashLen, this.ctx.sampleRate);
    const cd = crashBuf.getChannelData(0);
    for (let i = 0; i < crashLen; i++) cd[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / crashLen, 1.5);
    const crashSrc = this.ctx.createBufferSource();
    crashSrc.buffer = crashBuf;
    const crashHP = this.ctx.createBiquadFilter();
    crashHP.type = 'highpass'; crashHP.frequency.value = 4000;
    const crashG = this.ctx.createGain();
    crashG.gain.setValueAtTime(0.12, t + 0.3);
    crashG.gain.exponentialRampToValueAtTime(0.001, t + 1.2);
    crashSrc.connect(crashHP); crashHP.connect(crashG); crashG.connect(out);
    crashSrc.start(t + 0.3);
    // 4. Triumphant major chime at peak (C5, E5, G5)
    [523.25, 659.25, 783.99].forEach((freq, i) => {
      const osc = this.ctx.createOscillator();
      osc.type = 'sine';
      osc.frequency.value = freq;
      const g = this.ctx.createGain();
      g.gain.setValueAtTime(0, t + 0.5 + i * 0.08);
      g.gain.linearRampToValueAtTime(0.1, t + 0.55 + i * 0.08);
      g.gain.exponentialRampToValueAtTime(0.001, t + 1.3 + i * 0.08);
      osc.connect(g); g.connect(out);
      if (this._reverbSend) {
        const rs = this.ctx.createGain();
        rs.gain.value = 0.5;
        g.connect(rs); rs.connect(this._reverbSend);
      }
      osc.start(t + 0.5 + i * 0.08);
      osc.stop(t + 1.4 + i * 0.08);
    });
  }

  playBossSpawn() {
    if (!this.ctx || this.muted) return;
    const t = this.ctx.currentTime;
    const out = this._out();
    // Ominous brass-like swell
    const osc = this.ctx.createOscillator();
    const g = this.ctx.createGain();
    osc.type = 'sawtooth';
    osc.frequency.value = 65.41; // C2
    const lp = this.ctx.createBiquadFilter();
    lp.type = 'lowpass';
    lp.frequency.setValueAtTime(200, t);
    lp.frequency.linearRampToValueAtTime(800, t + 0.5);
    g.gain.setValueAtTime(0, t);
    g.gain.linearRampToValueAtTime(0.18, t + 0.3);
    g.gain.setValueAtTime(0.18, t + 0.5);
    g.gain.exponentialRampToValueAtTime(0.001, t + 0.8);
    osc.connect(lp); lp.connect(g); g.connect(out);
    osc.start(t); osc.stop(t + 0.8);
    // Sub rumble
    const sub = this.ctx.createOscillator();
    sub.type = 'sine';
    sub.frequency.value = 40;
    const sg = this.ctx.createGain();
    sg.gain.setValueAtTime(0.25, t);
    sg.gain.exponentialRampToValueAtTime(0.001, t + 0.6);
    sub.connect(sg); sg.connect(out);
    sub.start(t); sub.stop(t + 0.6);
  }

  playDeath() {
    if (!this.ctx || this.muted) return;
    const t = this.ctx.currentTime;
    const out = this._out();
    // Descending tone
    const osc = this.ctx.createOscillator();
    const g = this.ctx.createGain();
    osc.type = 'sawtooth';
    osc.frequency.setValueAtTime(400, t);
    osc.frequency.exponentialRampToValueAtTime(60, t + 0.5);
    g.gain.setValueAtTime(0.25, t);
    g.gain.exponentialRampToValueAtTime(0.001, t + 0.5);
    osc.connect(g); g.connect(out);
    osc.start(t); osc.stop(t + 0.5);
    // Crunch noise
    const bufLen = this.ctx.sampleRate * 0.3;
    const buf = this.ctx.createBuffer(1, bufLen, this.ctx.sampleRate);
    const d = buf.getChannelData(0);
    for (let i = 0; i < bufLen; i++) d[i] = (Math.random() * 2 - 1) * Math.exp(-i / (bufLen * 0.1));
    const src = this.ctx.createBufferSource();
    src.buffer = buf;
    const g2 = this.ctx.createGain();
    g2.gain.setValueAtTime(0.15, t + 0.05);
    g2.gain.exponentialRampToValueAtTime(0.001, t + 0.35);
    src.connect(g2); g2.connect(out);
    src.start(t + 0.05);
  }

  playBossKill() {
    if (!this.ctx || this.muted) return;
    const t = this.ctx.currentTime;
    const out = this._out();
    // Boom
    const osc = this.ctx.createOscillator();
    const g = this.ctx.createGain();
    osc.type = 'sine';
    osc.frequency.setValueAtTime(80, t);
    osc.frequency.exponentialRampToValueAtTime(30, t + 0.4);
    g.gain.setValueAtTime(0.35, t);
    g.gain.exponentialRampToValueAtTime(0.001, t + 0.4);
    osc.connect(g); g.connect(out);
    osc.start(t); osc.stop(t + 0.4);
    // Crackle
    const bufLen = this.ctx.sampleRate * 0.5;
    const buf = this.ctx.createBuffer(1, bufLen, this.ctx.sampleRate);
    const d = buf.getChannelData(0);
    for (let i = 0; i < bufLen; i++) d[i] = (Math.random() * 2 - 1) * Math.exp(-i / (bufLen * 0.2)) * 0.3;
    const src = this.ctx.createBufferSource();
    src.buffer = buf;
    const g2 = this.ctx.createGain();
    g2.gain.value = 0.15;
    src.connect(g2); g2.connect(out);
    src.start(t);
    // Satisfying ring
    const osc2 = this.ctx.createOscillator();
    const g3 = this.ctx.createGain();
    osc2.type = 'sine';
    osc2.frequency.value = 880;
    g3.gain.setValueAtTime(0.1, t + 0.1);
    g3.gain.exponentialRampToValueAtTime(0.001, t + 0.6);
    osc2.connect(g3); g3.connect(out);
    osc2.start(t + 0.1); osc2.stop(t + 0.6);
  }

  playStreakMilestone() {
    if (!this.ctx || this.muted) return;
    const t = this.ctx.currentTime;
    const out = this._out();
    const notes = [523, 659, 784]; // C5, E5, G5
    notes.forEach((freq, i) => {
      const osc = this.ctx.createOscillator();
      const g = this.ctx.createGain();
      osc.type = 'sine';
      osc.frequency.value = freq;
      g.gain.setValueAtTime(0.12, t + i * 0.1);
      g.gain.exponentialRampToValueAtTime(0.001, t + i * 0.1 + 0.2);
      osc.connect(g); g.connect(out);
      osc.start(t + i * 0.1);
      osc.stop(t + i * 0.1 + 0.2);
    });
  }
}

const soundEngine = new SoundEngine();

// ============================================================
// Main Game
// ============================================================
class Game {
  constructor() {
    this.canvas = document.getElementById('game');
    this.ctx = this.canvas.getContext('2d');

    this.running = false;
    this.gameTime = 0;
    this.phase = 0;
    this.projectiles = [];
    this.warnings = [];
    this.particles = [];
    this.powerups = [];
    this.shockwaves = [];
    this.bosses = [];
    this.dodgedCount = 0;
    this.bossesDefeated = 0;
    this.closestCall = Infinity;
    this.totalGames = parseInt(localStorage.getItem('dodge-ai-games') || '0');
    migrateBestTime();
    const bests = loadBests();
    if (bests.length > 0) {
      this.bestTime = bests[0].time;
    } else {
      this.bestTime = parseFloat(localStorage.getItem('dodge-ai-best') || '0');
    }

    this.player = { x: 0, y: 0, vx: 0, vy: 0 };
    this.targetX = 0;
    this.targetY = 0;

    this.effects = {
      slowmo: { active: false, remaining: 0, duration: 0 },
      shrink: { active: false, remaining: 0, duration: 0 },
      magnet: { active: false, remaining: 0, duration: 0 },
      vortex: { active: false, remaining: 0, duration: 0, x: 0, y: 0, delay: 0 },
    };

    // Ability system
    this.abilities = {
      dashBurst:  { unlocked: false, cooldown: 0, maxCooldown: 10, duration: 0.3, active: false, remaining: 0 },
      decoy:      { unlocked: false, cooldown: 0, maxCooldown: 12, duration: 3.0, active: false, remaining: 0 },
      phaseShift: { unlocked: false, cooldown: 0, maxCooldown: 15, duration: 0.5, active: false, remaining: 0 },
      timeWarp:   { unlocked: false, cooldown: 0, maxCooldown: 20, duration: 2.0, active: false, remaining: 0 },
    };
    this.activeAbility = null;
    this.decoyPos = null;
    this.milestones = { totalTimeSurvived: 0 };
    this.unlockAnnounce = null;

    this.lastPowerupType = null;
    this.brain = new AIBrain();
    this.rng = Math.random;
    this._lastShotWasCounter = false;
    this.threatLevel = 0;
    this.endgameMode = null;
    this.endgameCycleTimer = 0;
    this.recentCounterMisses = 0;
    this._threatAtCapDuration = 0;

    this.spawnTimer = 0;
    this.lastTime = 0;
    this.phaseAnnounceTimer = 0;
    this.bossAnnounceTimer = 0;
    this.powerupTimer = POWERUP_SPAWN_MIN + this.rng() * (POWERUP_SPAWN_MAX - POWERUP_SPAWN_MIN);
    this.pickupAnnounceTimer = 0;
    this.nextBossTime = BOSS_INTERVAL;
    this.bossLevel = 0;
    this._lastAnnouncedPhase = 0;
    this.deathContext = null;

    // Screen shake & flash (EMP)
    this.screenShake = { x: 0, y: 0, intensity: 0 };
    this.flashAlpha = 0;
    this.flashColor = '#fff';

    // Streak/Heat system
    this.streak = { heat: 0, tier: 0, tierName: '', peakTier: 0, peakTierName: '' };
    this.nearMissCooldown = 0;

    this.touchOffsetY = 50;
    this.safeArea = { top: 0, bottom: 0, left: 0, right: 0 };

    this.resize();
    window.addEventListener('resize', () => this.resize());
    this.setupInput();
    this.loadAbilities();
    this.updateStartScreen();

    this.bgStars = [];
    for (let i = 0; i < 60; i++) {
      this.bgStars.push({
        x: Math.random() * window.innerWidth,
        y: Math.random() * window.innerHeight,
        r: Math.random() * 1.2 + 0.3,
        a: Math.random(),
      });
    }

    this.idleLoop();
  }

  idleLoop() {
    if (this.running) return;
    const ctx = this.ctx;
    ctx.fillStyle = '#06060f';
    ctx.fillRect(0, 0, this.w, this.h);
    const t = Date.now() / 1000;
    for (const star of this.bgStars) {
      ctx.globalAlpha = star.a * 0.3 + Math.sin(t + star.x) * 0.08;
      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.arc(star.x, star.y + Math.sin(t * 0.3 + star.x * 0.01) * 2, star.r, 0, Math.PI * 2);
      ctx.fill();
    }
    ctx.globalAlpha = 1;
    requestAnimationFrame(() => this.idleLoop());
  }

  resize() {
    this.canvas.width = window.innerWidth;
    this.canvas.height = window.innerHeight;
    this.w = this.canvas.width;
    this.h = this.canvas.height;

    // Read safe area insets for canvas-side clamping
    const style = getComputedStyle(document.documentElement);
    this.safeArea = {
      top: parseFloat(style.getPropertyValue('--sa-top')) || 0,
      bottom: parseFloat(style.getPropertyValue('--sa-bottom')) || 0,
      left: parseFloat(style.getPropertyValue('--sa-left')) || 0,
      right: parseFloat(style.getPropertyValue('--sa-right')) || 0,
    };
  }

  loadAbilities() {
    try {
      const data = JSON.parse(localStorage.getItem('dodge-ai-abilities'));
      if (data) {
        if (data.unlocked) {
          for (const name of data.unlocked) {
            if (this.abilities[name]) this.abilities[name].unlocked = true;
          }
        }
        if (data.milestones) {
          this.milestones = { ...this.milestones, ...data.milestones };
        }
      }
    } catch (e) {}
  }

  saveAbilities() {
    const unlocked = Object.keys(this.abilities).filter(k => this.abilities[k].unlocked);
    localStorage.setItem('dodge-ai-abilities', JSON.stringify({
      unlocked,
      milestones: this.milestones,
      version: 1
    }));
  }

  checkMilestoneUnlocks() {
    this.milestones.totalTimeSurvived += this.gameTime;
    const bestRun = this.bestTime;
    const total = this.milestones.totalTimeSurvived;
    const thresholds = {
      dashBurst:  { totalTime: 300 },
      decoy:      { totalTime: 900 },
      phaseShift: { bestRun: 60 },
      timeWarp:   { totalTime: 2400 },
    };
    let newUnlock = null;
    for (const [name, req] of Object.entries(thresholds)) {
      if (this.abilities[name].unlocked) continue;
      const met = (!req.totalTime || total >= req.totalTime) &&
                  (!req.bestRun || bestRun >= req.bestRun);
      if (met) {
        this.abilities[name].unlocked = true;
        newUnlock = name;
      }
    }
    this.saveAbilities();
    return newUnlock;
  }

  activateAbility() {
    if (!this.running) return;
    const order = ['dashBurst', 'decoy', 'phaseShift', 'timeWarp'];
    const available = order.find(name => {
      const a = this.abilities[name];
      return a.unlocked && a.cooldown <= 0 && !a.active;
    });
    if (!available) return;

    const ability = this.abilities[available];
    ability.active = true;
    ability.remaining = ability.duration;
    ability.cooldown = ability.maxCooldown;
    this.activeAbility = available;

    if (available === 'dashBurst') {
      const speed = Math.sqrt(this.player.vx * this.player.vx + this.player.vy * this.player.vy);
      if (speed > 0.1) {
        this.player.x += (this.player.vx / speed) * 100;
        this.player.y += (this.player.vy / speed) * 100;
      } else {
        this.player.y -= 100;
      }
      this.player.x = Math.max(10, Math.min(this.w - 10, this.player.x));
      this.player.y = Math.max(10, Math.min(this.h - 10, this.player.y));
      // Shockwave push nearby projectiles
      for (const p of this.projectiles) {
        const dx = p.x - this.player.x;
        const dy = p.y - this.player.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist < 80 && dist > 0) {
          const push = 3;
          p.vx += (dx / dist) * push;
          p.vy += (dy / dist) * push;
        }
      }
      // Shockwave visual
      this.shockwaves.push(new Shockwave(this.player.x, this.player.y, 80, '#00ffaa', 0.4));
      // Burst particles
      for (let i = 0; i < 12; i++) {
        const a = Math.random() * Math.PI * 2;
        this.particles.push(new Particle(this.player.x, this.player.y, Math.cos(a) * 120, Math.sin(a) * 120, 0.35, '#00ffaa', 2.5));
      }
    }

    else if (available === 'decoy') {
      this.decoyPos = { x: this.player.x, y: this.player.y, age: 0 };
    }
  }

  setupInput() {
    const onMove = (x, y) => { this.targetX = x; this.targetY = y; };
    this.canvas.addEventListener('mousemove', e => onMove(e.clientX, e.clientY));
    this.canvas.addEventListener('touchmove', e => {
      e.preventDefault();
      onMove(e.touches[0].clientX, e.touches[0].clientY - this.touchOffsetY);
    }, { passive: false });
    this.canvas.addEventListener('touchstart', e => {
      e.preventDefault();
      onMove(e.touches[0].clientX, e.touches[0].clientY - this.touchOffsetY);
    }, { passive: false });

    // iOS Safari pinch-to-zoom prevention
    document.addEventListener('gesturestart', e => e.preventDefault(), { passive: false });
    document.addEventListener('gesturechange', e => e.preventDefault(), { passive: false });
    document.addEventListener('gestureend', e => e.preventDefault(), { passive: false });

    // Additional pinch prevention via multi-touch scale check
    document.addEventListener('touchmove', e => {
      if (e.scale !== undefined && e.scale !== 1) {
        e.preventDefault();
      }
    }, { passive: false });

    // Spacebar: activate ability (desktop)
    document.addEventListener('keydown', e => {
      if (e.code === 'Space' && this.running) {
        e.preventDefault();
        this.activateAbility();
      }
    });

    // Mobile ability button
    const abilityBtn = document.getElementById('ability-btn');
    if (abilityBtn) {
      abilityBtn.addEventListener('touchstart', e => {
        e.preventDefault();
        this.activateAbility();
      }, { passive: false });
    }

    // Mute button
    document.getElementById('mute-btn').onclick = () => {
      const muted = soundEngine.toggleMute();
      document.getElementById('mute-btn').classList.toggle('muted', muted);
      document.getElementById('mute-btn').innerHTML = muted ? '&#9835;' : '&#9834;';
    };

    document.getElementById('btn-start').onclick = () => this.start();
    document.getElementById('btn-retry').onclick = () => this.start();
    document.getElementById('btn-share').onclick = () => this.share();
    document.getElementById('btn-menu').onclick = () => {
      document.getElementById('gameover-screen').classList.remove('show');
      document.getElementById('start-screen').classList.remove('hidden');
      document.getElementById('ad-zone').style.display = 'none';
      this.updateStartScreen();
      this.idleLoop();
    };

    // Menu modals
    document.getElementById('btn-howto').onclick = () => {
      document.getElementById('modal-howto').classList.add('show');
    };
    document.getElementById('btn-stats').onclick = () => {
      const grid = document.getElementById('stats-grid');
      const dom = this.brain.getDominantDodge();
      const reaction = this.brain.getAvgReaction();
      // Remove previous bests section to prevent duplicates on re-open
      const existingBests = document.querySelector('.bests-list');
      if (existingBests) existingBests.remove();
      grid.innerHTML = `
        <div class="stat-item"><div class="stat-val">${this.bestTime > 0 ? this.bestTime.toFixed(1) + 's' : '\u2014'}</div><div class="stat-label">Longest Not-Dead</div></div>
        <div class="stat-item"><div class="stat-val">${this.totalGames}</div><div class="stat-label">Lives Sacrificed</div></div>
        <div class="stat-item"><div class="stat-val">${this.brain.getConfidence()}%</div><div class="stat-label">How Screwed You Are</div></div>
        <div class="stat-item"><div class="stat-val">${this.brain.totalSamples}</div><div class="stat-label">Your Moves Stolen</div></div>
        <div class="stat-item"><div class="stat-val">${dom ? dom.direction + ' ' + dom.pct + '%' : '\u2014'}</div><div class="stat-label">Predictable Dodge</div></div>
        <div class="stat-item"><div class="stat-val">${reaction ? reaction + 'ms' : '\u2014'}</div><div class="stat-label">Reaction Time</div></div>
      `;
      // Personal bests section
      const bests = loadBests();
      let bestsHTML = '<div class="bests-list"><h3>PERSONAL BESTS</h3>';
      if (bests.length === 0) {
        bestsHTML += '<div class="bests-empty">No games played yet</div>';
      } else {
        bestsHTML += '<ol>';
        bests.forEach((b, i) => {
          const dateStr = b.date === 'legacy' ? 'Pre-update' : new Date(b.date + 'T00:00:00').toLocaleDateString(undefined, { month: 'short', day: 'numeric', year: 'numeric' });
          bestsHTML += `<li><span class="best-rank">${i + 1}.</span><span class="best-time">${b.time.toFixed(1)}s</span><span class="best-date">${dateStr}</span></li>`;
        });
        bestsHTML += '</ol>';
      }
      bestsHTML += '</div>';
      grid.insertAdjacentHTML('afterend', bestsHTML);
      document.getElementById('modal-stats').classList.add('show');
    };
    document.getElementById('btn-contact').onclick = () => {
      window.location.href = 'mailto:znjeim@gmail.com';
    };
    document.getElementById('btn-feedback').onclick = () => {
      document.getElementById('modal-feedback').classList.add('show');
    };
    document.getElementById('btn-submit-feedback').onclick = () => {
      const text = document.getElementById('feedback-text').value.trim();
      if (!text) return;
      try {
        const existing = JSON.parse(localStorage.getItem('dodge-ai-feedback') || '[]');
        existing.push({ text, time: new Date().toISOString() });
        localStorage.setItem('dodge-ai-feedback', JSON.stringify(existing));
      } catch(e) {}
      document.getElementById('feedback-text').value = '';
      const status = document.getElementById('feedback-status');
      status.style.display = 'block';
      setTimeout(() => { status.style.display = 'none'; }, 3000);
    };
    document.getElementById('btn-reset-ai').onclick = () => {
      if (confirm('Reset AI brain data? This cannot be undone.')) {
        localStorage.removeItem('dodge-ai-brain');
        this.brain = new AIBrain();
      }
    };

    // Modal close buttons
    document.querySelectorAll('.modal-close').forEach(btn => {
      btn.onclick = () => {
        const modalId = btn.getAttribute('data-close');
        if (modalId) document.getElementById(modalId).classList.remove('show');
      };
    });
  }

  updateStartScreen() {
    const bests = loadBests();
    const best = bests.length > 0 ? bests[0].time : 0;
    const el = document.getElementById('start-best');
    el.textContent = best > 0 ? `Best: ${best.toFixed(1)}s` : '';
  }

  start() {
    document.getElementById('start-screen').classList.add('hidden');
    document.getElementById('gameover-screen').classList.remove('show');
    this.canvas.classList.add('active');
    document.getElementById('ad-zone').style.display = 'none';
    document.querySelectorAll('.modal-overlay').forEach(m => m.classList.remove('show'));

    this.rng = Math.random;
    this.running = true;
    this.gameTime = 0;
    this.phase = 0;
    this.projectiles = [];
    this.warnings = [];
    this.particles = [];
    this.powerups = [];
    this.shockwaves = [];
    this.bosses = [];
    this.dodgedCount = 0;
    this.bossesDefeated = 0;
    this.closestCall = Infinity;
    this.spawnTimer = 1.2;
    this.phaseAnnounceTimer = 0;
    this.bossAnnounceTimer = 0;
    this.powerupTimer = 6 + this.rng() * 4;
    this.nextBossTime = BOSS_INTERVAL;
    this.bossLevel = 0;
    this._lastAnnouncedPhase = 0;

    this.effects.slowmo = { active: false, remaining: 0, duration: 0 };
    this.effects.shrink = { active: false, remaining: 0, duration: 0 };
    this.effects.magnet = { active: false, remaining: 0, duration: 0 };
    this.effects.vortex = { active: false, remaining: 0, duration: 0, x: 0, y: 0, delay: 0 };
    // Reset ability active states and cooldowns (but NOT unlocked status)
    for (const a of Object.values(this.abilities)) {
      a.cooldown = 0; a.active = false; a.remaining = 0;
    }
    this.activeAbility = null;
    this.decoyPos = null;
    this.unlockAnnounce = null;
    this.lastPowerupType = null;
    this.deathContext = null;
    this._lastShotWasCounter = false;
    this.threatLevel = 0;
    this.endgameMode = null;
    this.endgameCycleTimer = 0;
    this.recentCounterMisses = 0;
    this._threatAtCapDuration = 0;

    this.player.x = this.w / 2;
    this.player.y = this.h / 2;
    this.player.vx = 0;
    this.player.vy = 0;
    this.targetX = this.w / 2;
    this.targetY = this.h / 2;

    this.brain.reset();
    this.lastTime = performance.now();

    // Reset streak/heat
    this.streak = { heat: 0, tier: 0, tierName: '', peakTier: 0, peakTierName: '' };
    this.nearMissCooldown = 0;
    this.screenShake = { x: 0, y: 0, intensity: 0 };
    this.flashAlpha = 0;

    // Sound
    soundEngine.init();
    soundEngine.resume();
    soundEngine.startMusic();

    // Heat bar visible
    document.getElementById('heat-bar-container').style.display = 'block';

    this.announcePhase();
    requestAnimationFrame(t => this.loop(t));

    // Analytics
    _gameEverStarted = true;
    _sessionGamesPlayed++;
    trackEvent('game-start', `Game ${_sessionGamesPlayed} started`);
    if (_sessionGamesPlayed === 1) {
      trackEvent('milestone-first-game', 'First game this session');
    }
  }

  loop(timestamp) {
    if (!this.running) return;
    try {
      const dt = Math.min((timestamp - this.lastTime) / 1000, 0.05);
      this.lastTime = timestamp;
      this.update(dt);
      this.render();
      this.updateUI();
      this._loopErrors = 0;
    } catch (e) {
      console.error('Game loop error:', e);
      this._loopErrors = (this._loopErrors || 0) + 1;
      if (this._loopErrors > 10) {
        console.error('Too many loop errors, stopping game');
        this.running = false;
        this.canvas.classList.remove('active');
        return;
      }
    }
    requestAnimationFrame(t => this.loop(t));
  }

  getPlayerRadius() {
    return this.effects.shrink.active ? PLAYER_RADIUS * 0.5 : PLAYER_RADIUS;
  }

  getSlowMod() {
    let mod = this.effects.slowmo.active ? 0.3 : 1;
    if (this.abilities.timeWarp.active) mod *= 0.3;
    return mod;
  }

  // Get current phase params (computed, not mutating PHASE_DEFS)
  getPhaseDef() {
    let base;
    if (this.phase < PHASE_DEFS.length - 1) {
      base = { ...PHASE_DEFS[this.phase] };
    } else {
      // EVOLVED: ramp values dynamically without mutating originals
      const phaseDurations = PHASE_DEFS.slice(0, 5).reduce((s, p) => s + p.dur, 0);
      const t = Math.max(0, this.gameTime - phaseDurations);
      const ramp = Math.floor(t / 20);
      base = {
        ...EVOLVED_BASE,
        speed: 6.0 + ramp * 0.4,
        spawnRate: Math.max(0.2, 0.35 - ramp * 0.03),
        count: Math.min(6, 4 + Math.floor(t / 30)),
        homingChance: Math.min(0.5, 0.3 + Math.floor(t / 30) * 0.05),
        splitterChance: Math.min(0.4, 0.3 + ramp * 0.02),
        bouncerChance: Math.min(0.3, 0.2 + ramp * 0.02),
        waveChance: Math.min(0.3, 0.2 + ramp * 0.02),
        accelChance: Math.min(0.35, 0.25 + ramp * 0.02),
        spiralChance: Math.min(0.3, 0.2 + ramp * 0.02),
        clusterChance: Math.min(0.3, 0.2 + ramp * 0.02),
        mineChance: Math.min(0.25, 0.15 + ramp * 0.02),
      };
    }

    // Apply threat level modifiers (adaptive difficulty — smooth ramp)
    const tl = this.threatLevel || 0;
    const result = {
      ...base,
      aimPct: Math.min(0.95, base.aimPct + tl * 0.08),
      speed: base.speed + tl * 0.8,
      spawnRate: base.spawnRate * (1 - tl * 0.15),
      counterPatternChance: tl * 0.4,
    };

    // Endgame mode modifiers (cycling at max threat)
    if (this.endgameMode) {
      switch (this.endgameMode) {
        case 'zone-denial':
          result.counterPatternChance = Math.min(0.8, result.counterPatternChance + 0.3);
          break;
        case 'prediction-spam':
          result.aimPct = Math.min(0.99, result.aimPct + 0.08);
          result.homingChance = Math.min(0.5, (result.homingChance || 0) + 0.1);
          break;
        case 'speed-pressure':
          result.speed += 1.5;
          result.spawnRate = Math.max(0.15, result.spawnRate * 0.7);
          break;
      }
    }

    return result;
  }

  update(dt) {
    this.gameTime += dt;
    this.spawnTimer -= dt;

    // --- Announce timers (must tick before any early return) ---
    if (this.phaseAnnounceTimer > 0) this.phaseAnnounceTimer -= dt;
    if (this.bossAnnounceTimer > 0) this.bossAnnounceTimer -= dt;
    if (this.pickupAnnounceTimer > 0) this.pickupAnnounceTimer -= dt;
    if (this.pickupAnnounceTimer <= 0) {
      document.getElementById('pickup-announce').classList.remove('show');
    }

    // --- Phase progression ---
    let elapsed = this.gameTime;
    for (let i = 0; i < this.phase; i++) elapsed -= PHASE_DEFS[i].dur;
    while (elapsed >= PHASE_DEFS[this.phase].dur && this.phase < PHASE_DEFS.length - 1) {
      this.phase++;
      elapsed -= PHASE_DEFS[this.phase - 1].dur;
    }
    if (this.phase !== this._lastAnnouncedPhase) {
      this._lastAnnouncedPhase = this.phase;
      this.announcePhase();
      // Analytics: phase milestone
      trackEvent(`milestone-phase-${this.phase + 1}`, `Reached Phase ${this.phase + 1}: ${PHASE_DEFS[this.phase].name}`);
    }

    // --- Move player ---
    const prevX = this.player.x;
    const prevY = this.player.y;
    let lerp = PLAYER_LERP;
    if (this.abilities.timeWarp.active) lerp *= 0.7;
    this.player.x += (this.targetX - this.player.x) * lerp;
    this.player.y += (this.targetY - this.player.y) * lerp;
    this.player.vx = this.player.x - prevX;
    this.player.vy = this.player.y - prevY;

    const pr = this.getPlayerRadius();
    const sa = this.safeArea;
    this.player.x = Math.max(pr + sa.left, Math.min(this.w - pr - sa.right, this.player.x));
    this.player.y = Math.max(pr + sa.top, Math.min(this.h - pr - sa.bottom, this.player.y));

    this.brain.trackPosition(this.player.x, this.player.y, this.gameTime * 1000, this.w, this.h);
    this.updateThreatLevel(dt);
    this.updateEndgameCycle(dt);

    // --- Spawn projectiles ---
    if (this.spawnTimer <= 0 && this.phaseAnnounceTimer <= 0 && this.bossAnnounceTimer <= 0) {
      this.spawnWarnings();
      this.spawnTimer = this.getPhaseDef().spawnRate;
    }

    // --- Warnings -> projectiles ---
    const now = this.gameTime * 1000;
    for (let i = this.warnings.length - 1; i >= 0; i--) {
      if (this.warnings[i].isExpired(now)) {
        this.spawnProjectileFromWarning(this.warnings[i]);
        this.warnings.splice(i, 1);
      }
    }

    // --- Magnet repel force ---
    if (this.effects.magnet.active) {
      const repelRadius = 150;
      const repelForce = 400;
      for (const p of this.projectiles) {
        const rdx = p.x - this.player.x;
        const rdy = p.y - this.player.y;
        const rdist = Math.sqrt(rdx * rdx + rdy * rdy);
        if (rdist < repelRadius && rdist > 1) {
          const strength = (1 - rdist / repelRadius) * repelForce * dt;
          p.vx += (rdx / rdist) * strength;
          p.vy += (rdy / rdist) * strength;
        }
      }
    }

    // --- Vortex gravity well ---
    if (this.effects.vortex.active) {
      // Tick down spawn delay
      if (this.effects.vortex.delay > 0) {
        const wasPending = this.effects.vortex.delay > 0;
        this.effects.vortex.delay -= dt;
        // Black hole just opened — shockwave burst
        if (wasPending && this.effects.vortex.delay <= 0) {
          this.effects.vortex.delay = 0;
          const bx = this.effects.vortex.x, by = this.effects.vortex.y;
          this.shockwaves.push(new Shockwave(bx, by, 120, '#a855f7', 0.6));
          this.shockwaves.push(new Shockwave(bx, by, 60, '#fff', 0.3));
        }
      } else {
        // Black hole is live — pull and destroy projectiles
        const vx = this.effects.vortex.x;
        const vy = this.effects.vortex.y;
        const screenDiag = Math.sqrt(this.w * this.w + this.h * this.h);
        const pullRadius = screenDiag * 0.8;
        const destroyRadius = 44;
        const pullForce = 800;
        for (let i = this.projectiles.length - 1; i >= 0; i--) {
          const p = this.projectiles[i];
          const dx = vx - p.x;
          const dy = vy - p.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          if (dist < destroyRadius) {
            this.particles.push(new Particle(p.x, p.y, 0, 0, 0.3, '#a855f7', 1.5));
            this.projectiles.splice(i, 1);
          } else if (dist < pullRadius && dist > 1) {
            const strength = (1 - dist / pullRadius) * pullForce * dt;
            p.vx += (dx / dist) * strength;
            p.vy += (dy / dist) * strength;
          }
        }
      }
    }

    // --- Update projectiles ---
    const slowMod = this.getSlowMod();
    const newProjectiles = [];
    for (let i = this.projectiles.length - 1; i >= 0; i--) {
      const p = this.projectiles[i];
      p.update(dt, this.player.x, this.player.y, slowMod);

      // Bouncer check
      p.checkBounce(this.w, this.h);

      // Splitter check
      const children = p.checkSplit(this.w, this.h);
      if (children) {
        newProjectiles.push(...children);
        // Spawn split particles
        for (let j = 0; j < 6; j++) {
          const a = Math.random() * Math.PI * 2;
          this.particles.push(new Particle(p.x, p.y, Math.cos(a) * 60, Math.sin(a) * 60, 0.3, '#ff69b4', 2));
        }
      }

      // Cluster explosion check
      const clusterChildren = p.checkCluster();
      if (clusterChildren) {
        newProjectiles.push(...clusterChildren);
        for (let j = 0; j < 8; j++) {
          const a = Math.random() * Math.PI * 2;
          this.particles.push(new Particle(p.x, p.y, Math.cos(a) * 80, Math.sin(a) * 80, 0.4, '#ff8800', 2.5));
        }
      }

      // Mine detonation check
      const mineChildren = p.checkMineDetonate(this.player.x, this.player.y);
      if (mineChildren) {
        newProjectiles.push(...mineChildren);
        for (let j = 0; j < 6; j++) {
          const a = Math.random() * Math.PI * 2;
          this.particles.push(new Particle(p.x, p.y, Math.cos(a) * 50, Math.sin(a) * 50, 0.35, '#ff0066', 2));
        }
      }

      // Remove exploded clusters and detonated mines
      if (p.hasExploded || p.hasDetonated) {
        this.projectiles.splice(i, 1);
        continue;
      }

      const dx = p.x - this.player.x;
      const dy = p.y - this.player.y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      const hitDist = pr + p.radius;

      if (dist < hitDist) {
        // Dash Burst: brief invulnerability during teleport
        if (this.abilities.dashBurst.active) continue;
        // Phase Shift: projectiles pass through
        if (this.abilities.phaseShift.active) {
          if (Math.random() < 0.4) {
            this.particles.push(new Particle(p.x, p.y, 0, 0, 0.15, 'rgba(0,255,170,0.5)', 1.5));
          }
          continue;
        }
        this.deathContext = {
          type: 'projectile',
          subtype: p.type,
          homing: p.homing || false,
          color: p.color,
          x: p.x,
          y: p.y,
          vx: p.vx,
          vy: p.vy,
          angle: Math.atan2(p.y - this.player.y, p.x - this.player.x),
          playerX: this.player.x,
          playerY: this.player.y,
          bossName: null,
        };
        this.die();
        return;
      }

      if (dist < this.closestCall && p.age > 0.15) this.closestCall = dist;

      if (p.isOffscreen(this.w, this.h) && (p.type !== 'bouncer' || p.bounces >= p.maxBounces)) {
        this.dodgedCount++;
        if (p.isCounter) this.recentCounterMisses++;
        this.projectiles.splice(i, 1);
      }
    }
    // Add split/cluster/mine children
    for (const c of newProjectiles) this.projectiles.push(c);

    // --- Power-ups spawn ---
    this.powerupTimer -= dt;
    if (this.powerupTimer <= 0) {
      this.spawnPowerup();
      this.powerupTimer = POWERUP_SPAWN_MIN + this.rng() * (POWERUP_SPAWN_MAX - POWERUP_SPAWN_MIN);
    }

    // --- Update power-ups ---
    for (let i = this.powerups.length - 1; i >= 0; i--) {
      const pu = this.powerups[i];
      pu.update(dt);
      const dx = pu.x - this.player.x;
      const dy = pu.y - this.player.y;
      if (Math.sqrt(dx * dx + dy * dy) < pr + POWERUP_RADIUS) {
        this.collectPowerup(pu);
        this.powerups.splice(i, 1);
        continue;
      }
      if (pu.isExpired()) this.powerups.splice(i, 1);
    }

    // --- Boss spawning ---
    if (this.gameTime >= this.nextBossTime && this.bossAnnounceTimer <= 0 && this.phase >= 1) {
      this.announceBoss();
      this.nextBossTime = this.gameTime + BOSS_INTERVAL;
    }

    // --- Update bosses ---
    for (let i = this.bosses.length - 1; i >= 0; i--) {
      const boss = this.bosses[i];
      boss.update(dt, this.player.x, this.player.y);

      // Collect boss projectiles
      for (const proj of boss.pendingProjectiles) {
        this.projectiles.push(proj);
      }

      // Collision check (includes segments for Serpent)
      const collisionPoints = boss.getCollisionPoints();
      let bossCollided = false;
      for (const cp of collisionPoints) {
        const cdx = cp.x - this.player.x;
        const cdy = cp.y - this.player.y;
        const cdist = Math.sqrt(cdx * cdx + cdy * cdy);
        if (cdist < pr + cp.radius) {
          bossCollided = true;
          break;
        }
      }

      if (bossCollided) {
        this.deathContext = {
          type: 'boss',
          subtype: boss.bossType?.shape || 'boss',
          homing: false,
          color: boss.color,
          x: boss.x,
          y: boss.y,
          vx: 0,
          vy: 0,
          angle: Math.atan2(boss.y - this.player.y, boss.x - this.player.x),
          playerX: this.player.x,
          playerY: this.player.y,
          bossName: boss.bossType?.name || 'Unknown Boss',
        };
        this.die();
        return;
      }

      // Toxic trail collision
      if (boss.trailSegments && !this.abilities.phaseShift.active) {
        for (const ts of boss.trailSegments) {
          const tdx = ts.x - this.player.x;
          const tdy = ts.y - this.player.y;
          const tdist = Math.sqrt(tdx * tdx + tdy * tdy);
          if (tdist < pr + 8) {
            this.deathContext = {
              type: 'boss', subtype: 'toxic-trail', homing: false,
              color: '#10b981', x: ts.x, y: ts.y, vx: 0, vy: 0,
              angle: Math.atan2(ts.y - this.player.y, ts.x - this.player.x),
              playerX: this.player.x, playerY: this.player.y,
              bossName: 'Mr Wiggles (Toxic Trail)',
            };
            this.die();
            return;
          }
        }
      }

      if (boss.isExpired()) {
        this.bossDeathEffect(boss);
        this.bosses.splice(i, 1);
        this.bossesDefeated++;
        this.dodgedCount += 5;
        this.streak.heat = Math.min(100, this.streak.heat + 20);
      }
    }

    // --- Update effects ---
    for (const key of ['slowmo', 'shrink', 'magnet', 'vortex']) {
      const eff = this.effects[key];
      if (eff.active) {
        eff.remaining -= dt;
        if (eff.remaining <= 0) {
          eff.active = false;
          eff.remaining = 0;
        }
      }
    }

    // --- Update abilities ---
    for (const [name, a] of Object.entries(this.abilities)) {
      if (a.cooldown > 0) a.cooldown -= dt;
      if (a.active) {
        a.remaining -= dt;
        if (a.remaining <= 0) {
          a.active = false;
          a.remaining = 0;
          if (this.activeAbility === name) this.activeAbility = null;
          if (name === 'decoy') this.decoyPos = null;
        }
      }
    }

    // Decoy: attract homing projectiles toward decoy instead of player
    if (this.decoyPos) {
      this.decoyPos.age += dt;
      for (const p of this.projectiles) {
        if (p.homing && p.age < 3) {
          const ddx = this.decoyPos.x - p.x;
          const ddy = this.decoyPos.y - p.y;
          const ddist = Math.sqrt(ddx * ddx + ddy * ddy) || 1;
          p.vx += (ddx / ddist) * p.homingStrength * 60 * dt * 0.7;
          p.vy += (ddy / ddist) * p.homingStrength * 60 * dt * 0.7;
        }
      }
    }

    // --- Shockwaves ---
    for (let i = this.shockwaves.length - 1; i >= 0; i--) {
      this.shockwaves[i].update(dt);
      if (this.shockwaves[i].isDead()) this.shockwaves.splice(i, 1);
    }

    // --- Particles ---
    for (let i = this.particles.length - 1; i >= 0; i--) {
      this.particles[i].update(dt);
      if (this.particles[i].life <= 0) this.particles.splice(i, 1);
    }

    // Smart particle cap - trim oldest if over limit
    if (this.particles.length > 800) {
      this.particles.sort((a, b) => a.life - b.life);
      this.particles = this.particles.slice(this.particles.length - 500);
    }

    // --- Near-miss detection & streak system ---
    this.nearMissCooldown = Math.max(0, this.nearMissCooldown - dt);
    for (const p of this.projectiles) {
      const ndx = p.x - this.player.x;
      const ndy = p.y - this.player.y;
      const ndist = Math.sqrt(ndx * ndx + ndy * ndy);
      if (ndist < 25 && p.age > 0.15 && this.nearMissCooldown <= 0) {
        soundEngine.playNearMiss();
        this.streak.heat = Math.min(100, this.streak.heat + 15);
        this.nearMissCooldown = 0.15;
        break;
      } else if (ndist < 50 && ndist >= 25 && p.age > 0.15 && this.nearMissCooldown <= 0) {
        this.streak.heat = Math.min(100, this.streak.heat + 5);
        this.nearMissCooldown = 0.2;
        break;
      }
    }

    // Heat from time alive (+1 per 2 seconds)
    this.streak.heat = Math.min(100, this.streak.heat + dt * 0.5);
    // Heat decay
    this.streak.heat = Math.max(0, this.streak.heat - 3 * dt);

    // Tier calculation
    const prevTier = this.streak.tier;
    if (this.streak.heat >= 100) { this.streak.tier = 4; this.streak.tierName = 'UNSTOPPABLE'; }
    else if (this.streak.heat >= 75) { this.streak.tier = 3; this.streak.tierName = 'ON FIRE'; }
    else if (this.streak.heat >= 50) { this.streak.tier = 2; this.streak.tierName = 'HOT'; }
    else if (this.streak.heat >= 25) { this.streak.tier = 1; this.streak.tierName = 'WARM'; }
    else { this.streak.tier = 0; this.streak.tierName = ''; }

    if (this.streak.tier > this.streak.peakTier) {
      this.streak.peakTier = this.streak.tier;
      this.streak.peakTierName = this.streak.tierName;
    }

    if (this.streak.tier > prevTier && this.streak.tier > 0) {
      soundEngine.playStreakMilestone();
    }

    // --- Screen shake decay ---
    if (this.screenShake.intensity > 0) {
      this.screenShake.intensity *= Math.pow(0.05, dt);
      if (this.screenShake.intensity < 0.5) this.screenShake.intensity = 0;
      this.screenShake.x = (Math.random() - 0.5) * this.screenShake.intensity * 2;
      this.screenShake.y = (Math.random() - 0.5) * this.screenShake.intensity * 2;
    }

    // --- Flash decay ---
    if (this.flashAlpha > 0) {
      this.flashAlpha = Math.max(0, this.flashAlpha - dt * 3);
    }

    // --- Update music intensity ---
    soundEngine.updateMusicIntensity(this.phase, this.threatLevel);

    // Player trail — enhanced by streak tier
    const trailChance = 0.3 + this.streak.tier * 0.15;
    if (Math.random() < trailChance) {
      const trailColor = this.effects.shrink.active ? '#ec4899' : '#00f0ff';
      this.particles.push(new Particle(
        this.player.x, this.player.y,
        (Math.random() - 0.5) * 20, (Math.random() - 0.5) * 20,
        0.4, trailColor, 2
      ));
    }

  }

  spawnPowerup() {
    const types = Object.keys(POWERUP_TYPES);
    let type;
    do {
      type = types[Math.floor(this.rng() * types.length)];
    } while (type === this.lastPowerupType && types.length > 1);
    this.lastPowerupType = type;
    const margin = 60;
    const sa = this.safeArea;
    const x = margin + sa.left + this.rng() * (this.w - 2 * margin - sa.left - sa.right);
    const y = margin + sa.top + this.rng() * (this.h - 2 * margin - sa.top - sa.bottom);
    this.powerups.push(new PowerUp(x, y, type, this.gameTime));
  }

  collectPowerup(pu) {
    const def = pu.def;
    soundEngine.playCollect();

    // Pickup particles — burst outward
    for (let i = 0; i < 20; i++) {
      const angle = Math.random() * Math.PI * 2;
      this.particles.push(new Particle(
        pu.x, pu.y,
        Math.cos(angle) * 140, Math.sin(angle) * 140,
        0.6, def.color, 3
      ));
    }

    // Announce
    const el = document.getElementById('pickup-announce');
    el.textContent = def.name;
    el.style.color = def.color;
    el.style.textShadow = `0 0 20px ${def.color}`;
    el.classList.add('show');
    this.pickupAnnounceTimer = 1;

    if (pu.type === 'emp') {
      // === EMP ANIMATION ===
      soundEngine.playEMP();

      // Screen flash
      this.flashAlpha = 0.8;
      this.flashColor = '#fff';
      setTimeout(() => { this.flashAlpha = 0.4; this.flashColor = '#ff8800'; }, 100);

      // Screen shake
      this.screenShake.intensity = 15;

      // 5 staggered shockwaves from player
      const maxR = Math.max(this.w, this.h) * 0.7;
      const shockColors = ['#facc15', '#fff', '#ff8800', '#facc15', '#fff'];
      const shockSpeeds = [0.9, 0.7, 0.8, 0.6, 0.5];
      for (let si = 0; si < 5; si++) {
        setTimeout(() => {
          this.shockwaves.push(new Shockwave(this.player.x, this.player.y, maxR * (0.4 + si * 0.1), shockColors[si], shockSpeeds[si]));
        }, si * 60);
      }

      // Fireball at player center
      for (let fi = 0; fi < 20; fi++) {
        const a = Math.random() * Math.PI * 2;
        const sp = 20 + Math.random() * 60;
        const colors = ['#ff4400', '#ff8800', '#facc15', '#fff'];
        this.particles.push(new Particle(this.player.x, this.player.y, Math.cos(a) * sp, Math.sin(a) * sp, 0.6 + Math.random() * 0.3, colors[Math.floor(Math.random() * colors.length)], 4 + Math.random() * 4));
      }

      // Explode each projectile with staggered delay based on distance from player
      const sorted = [...this.projectiles].sort((a, b) => {
        const da = Math.sqrt((a.x - this.player.x) ** 2 + (a.y - this.player.y) ** 2);
        const db = Math.sqrt((b.x - this.player.x) ** 2 + (b.y - this.player.y) ** 2);
        return da - db;
      });
      sorted.forEach((p, idx) => {
        const delay = idx * 0.02;
        // 30 particles per projectile (mix of colors)
        const empColors = ['#facc15', '#ff8800', '#ff4400', '#fff'];
        for (let j = 0; j < 30; j++) {
          const a = Math.random() * Math.PI * 2;
          const sp = 40 + Math.random() * 120;
          this.particles.push(new Particle(p.x, p.y, Math.cos(a) * sp, Math.sin(a) * sp, 0.3 + delay + Math.random() * 0.3, empColors[Math.floor(Math.random() * empColors.length)], 1.5 + Math.random() * 2));
        }
        // Debris (larger, slower)
        for (let j = 0; j < 3; j++) {
          const a = Math.random() * Math.PI * 2;
          this.particles.push(new Particle(p.x, p.y, Math.cos(a) * 30, Math.sin(a) * 30, 0.8 + delay, '#ff8800', 4 + Math.random() * 3));
        }
        // Mini shockwave per projectile
        this.shockwaves.push(new Shockwave(p.x, p.y, 25, '#facc15', 0.3));
      });

      // Lingering embers (float upward)
      for (let e = 0; e < 40; e++) {
        const ex = this.player.x + (Math.random() - 0.5) * 300;
        const ey = this.player.y + (Math.random() - 0.5) * 300;
        const ec = Math.random() < 0.5 ? '#ff8800' : '#facc15';
        this.particles.push(new Particle(ex, ey, (Math.random() - 0.5) * 15, -20 - Math.random() * 30, 1.5 + Math.random() * 1, ec, 1 + Math.random()));
      }

      // Kill bosses with extra drama
      for (const boss of this.bosses) {
        // Extra dramatic boss death during EMP: 80 particles + 3 shockwaves
        for (let bi = 0; bi < 80; bi++) {
          const a = Math.random() * Math.PI * 2;
          const sp = 50 + Math.random() * 250;
          this.particles.push(new Particle(boss.x, boss.y, Math.cos(a) * sp, Math.sin(a) * sp, 0.8, boss.color, 2 + Math.random() * 4));
        }
        this.shockwaves.push(new Shockwave(boss.x, boss.y, boss.radius * 5, boss.color, 0.7));
        this.shockwaves.push(new Shockwave(boss.x, boss.y, boss.radius * 3, '#fff', 0.5));
        this.shockwaves.push(new Shockwave(boss.x, boss.y, boss.radius * 4, '#ff8800', 0.6));
        soundEngine.playBossKill();
        this.bossesDefeated++;
        this.dodgedCount += 10;
      }
      this.bosses = [];

      this.dodgedCount += this.projectiles.length;
      this.projectiles = [];
      this.warnings = [];

    } else if (pu.type === 'slowmo') {
      // === SLOW-MO ANIMATION ===
      this.shockwaves.push(new Shockwave(this.player.x, this.player.y, 200, '#3b82f6', 0.6));
      // Blue radial particles
      for (let i = 0; i < 12; i++) {
        const a = (i / 12) * Math.PI * 2;
        this.particles.push(new Particle(
          this.player.x + Math.cos(a) * 30, this.player.y + Math.sin(a) * 30,
          Math.cos(a) * 60, Math.sin(a) * 60, 0.8, '#3b82f6', 2
        ));
      }
      this.effects.slowmo.active = true;
      this.effects.slowmo.remaining = POWERUP_TYPES.slowmo.duration;
      this.effects.slowmo.duration = POWERUP_TYPES.slowmo.duration;

    } else if (pu.type === 'shrink') {
      // === SHRINK ANIMATION ===
      for (let i = 0; i < 16; i++) {
        const a = (i / 16) * Math.PI * 2;
        const dist = 60 + Math.random() * 30;
        this.particles.push(new Particle(
          this.player.x + Math.cos(a) * dist, this.player.y + Math.sin(a) * dist,
          -Math.cos(a) * 80, -Math.sin(a) * 80, 0.4, '#ec4899', 2.5
        ));
      }
      this.shockwaves.push(new Shockwave(this.player.x, this.player.y, 30, '#ec4899', 0.4));
      this.effects.shrink.active = true;
      this.effects.shrink.remaining = POWERUP_TYPES.shrink.duration;
      this.effects.shrink.duration = POWERUP_TYPES.shrink.duration;

    } else if (pu.type === 'vortex') {
      // === BLACK HOLE — 1.5s warning, then activates at pickup location ===
      const bx = pu.x, by = pu.y;
      // Warning particles spiral inward during delay
      for (let i = 0; i < 24; i++) {
        const a = (i / 24) * Math.PI * 2;
        const dist = 120 + Math.random() * 80;
        this.particles.push(new Particle(
          bx + Math.cos(a) * dist, by + Math.sin(a) * dist,
          -Math.cos(a) * 60, -Math.sin(a) * 60, 1.4, '#a855f7', 2
        ));
      }
      this.effects.vortex.active = true;
      this.effects.vortex.delay = 1.5;
      this.effects.vortex.remaining = POWERUP_TYPES.vortex.duration + 1.5;
      this.effects.vortex.duration = POWERUP_TYPES.vortex.duration + 1.5;
      this.effects.vortex.x = bx;
      this.effects.vortex.y = by;

    } else if (pu.type === 'magnet') {
      // === REPULSE ANIMATION ===
      this.shockwaves.push(new Shockwave(this.player.x, this.player.y, 200, '#f97316', 0.6));
      this.shockwaves.push(new Shockwave(this.player.x, this.player.y, 120, '#fff', 0.3));
      for (let i = 0; i < 10; i++) {
        const a = (i / 10) * Math.PI * 2;
        this.particles.push(new Particle(
          this.player.x, this.player.y,
          Math.cos(a) * 100, Math.sin(a) * 100, 0.5, '#f97316', 3
        ));
      }
      this.effects.magnet.active = true;
      this.effects.magnet.remaining = POWERUP_TYPES.magnet.duration;
      this.effects.magnet.duration = POWERUP_TYPES.magnet.duration;

    }
  }

  spawnWarnings() {
    const def = this.getPhaseDef();
    const count = def.count;
    const isBurst = this.rng() < def.burstChance;

    if (isBurst) {
      const edge = Math.floor(this.rng() * 4);
      let wx, wy;
      switch (edge) {
        case 0: wx = this.rng() * this.w; wy = 0; break;
        case 1: wx = this.w; wy = this.rng() * this.h; break;
        case 2: wx = this.rng() * this.w; wy = this.h; break;
        case 3: wx = 0; wy = this.rng() * this.h; break;
      }
      const fanCount = 3 + Math.floor(this.rng() * 3);
      for (let i = 0; i < fanCount; i++) {
        this.warnings.push(new Warning(
          wx + (this.rng() - 0.5) * 8,
          wy + (this.rng() - 0.5) * 8,
          this.gameTime * 1000 + i * 60
        ));
      }
    } else {
      for (let i = 0; i < count; i++) {
        const edge = Math.floor(this.rng() * 4);
        let wx, wy;
        switch (edge) {
          case 0: wx = this.rng() * this.w; wy = 0; break;
          case 1: wx = this.w; wy = this.rng() * this.h; break;
          case 2: wx = this.rng() * this.w; wy = this.h; break;
          case 3: wx = 0; wy = this.rng() * this.h; break;
        }
        this.warnings.push(new Warning(wx, wy, this.gameTime * 1000));
      }
    }
  }

  spawnProjectileFromWarning(warning) {
    // Cap total projectile count for performance (cluster/mine children can multiply quickly)
    if (this.projectiles.length >= 80) return;
    const def = this.getPhaseDef();
    const phase = this.phase;
    let targetX, targetY;
    const px = this.player.x;
    const py = this.player.y;
    const isHoming = this.rng() < def.homingChance;

    // Determine aim
    const aimRoll = this.rng();
    if (aimRoll > def.aimPct) {
      targetX = this.w * 0.15 + this.rng() * this.w * 0.7;
      targetY = this.h * 0.15 + this.rng() * this.h * 0.7;
    } else if (phase <= 1) {
      targetX = px + (this.rng() - 0.5) * 30;
      targetY = py + (this.rng() - 0.5) * 30;
    } else if (phase === 2) {
      const predicted = this.brain.getPredictedDodgeTarget(px, py, this.w, this.h);
      if (predicted && this.rng() < 0.65) { targetX = predicted.x; targetY = predicted.y; }
      else { targetX = px; targetY = py; }
    } else if (phase === 3) {
      const roll = this.rng();
      if (roll < 0.4) {
        const predicted = this.brain.getPredictedDodgeTarget(px, py, this.w, this.h);
        if (predicted) { targetX = predicted.x; targetY = predicted.y; }
        else { targetX = px; targetY = py; }
      } else if (roll < 0.7) {
        const zone = this.brain.getFavoriteZone(this.w, this.h);
        targetX = zone.x + (this.rng() - 0.5) * 50;
        targetY = zone.y + (this.rng() - 0.5) * 50;
      } else { targetX = px; targetY = py; }
    } else {
      const roll = this.rng();
      if (roll < 0.3) {
        const futurePos = this.brain.getPredictedFuturePos(px, py, this.player.vx * 60, this.player.vy * 60, 0.4 + this.rng() * 0.3);
        targetX = futurePos.x; targetY = futurePos.y;
      } else if (roll < 0.55) {
        const predicted = this.brain.getPredictedDodgeTarget(px, py, this.w, this.h);
        if (predicted) { targetX = predicted.x; targetY = predicted.y; }
        else { targetX = px; targetY = py; }
      } else if (roll < 0.75) {
        const zone = this.brain.getFavoriteZone(this.w, this.h);
        targetX = zone.x + (this.rng() - 0.5) * 40;
        targetY = zone.y + (this.rng() - 0.5) * 40;
      } else { targetX = px; targetY = py; }
    }

    // Counter-pattern targeting (AI fires based on detected patterns)
    const counterChance = def.counterPatternChance || 0;
    if (this.rng() < counterChance) {
      const gameTimeSec = this.gameTime;
      const pattern = this.brain.getHighestConfidencePattern(gameTimeSec);
      if (pattern) {
        let counterFired = false;
        switch (pattern.type) {
          case 'safe-zone': {
            const zoneCenter = this.brain.safeZoneDetector.getZoneCenter(pattern.zone, this.w, this.h);
            targetX = zoneCenter.x + (this.rng() - 0.5) * 50;
            targetY = zoneCenter.y + (this.rng() - 0.5) * 50;

            counterFired = true;
            break;
          }
          case 'direction-bias': {
            // AI silently targets based on detected direction bias
            const predicted = this.brain.getPredictedDodgeTarget(px, py, this.w, this.h);
            if (predicted) { targetX = predicted.x; targetY = predicted.y; }
            counterFired = true;
            break;
          }
          case 'panic-reversal': {
            targetX = px + Math.cos(pattern.dominantAngle) * 100;
            targetY = py + Math.sin(pattern.dominantAngle) * 100;
            counterFired = true;
            break;
          }
          case 'cornering': {
            const edgeTarget = this._getEdgeTarget(pattern.edge);
            if (edgeTarget) { targetX = edgeTarget.x; targetY = edgeTarget.y; }
            counterFired = true;
            break;
          }
          case 'dodge-sequence': {
            const nextDir = this.brain.dodgeSequenceDetector.predictNext(
              this.player.vx > 1 ? 'R' : this.player.vx < -1 ? 'L' : this.player.vy > 1 ? 'D' : 'U'
            );
            if (nextDir) {
              const offsets = { R: [80, 0], L: [-80, 0], U: [0, -80], D: [0, 80] };
              const off = offsets[nextDir];
              targetX = px + off[0] + (this.rng() - 0.5) * 30;
              targetY = py + off[1] + (this.rng() - 0.5) * 30;
              counterFired = true;
            }
            break;
          }
          case 'speed-freeze': {
            targetX = px;
            targetY = py;
            counterFired = true;
            break;
          }
        }

        if (counterFired) {
          this._lastShotWasCounter = true;
        }
      }
    }

    const dx = targetX - warning.x;
    const dy = targetY - warning.y;
    const dist = Math.sqrt(dx * dx + dy * dy) || 1;
    const speed = def.speed;

    // Determine special type
    let type = 'normal';
    const typeRoll = this.rng();
    if (typeRoll < def.splitterChance) type = 'splitter';
    else if (typeRoll < def.splitterChance + def.bouncerChance) type = 'bouncer';
    else if (typeRoll < def.splitterChance + def.bouncerChance + def.waveChance) type = 'wave';
    else if (typeRoll < def.splitterChance + def.bouncerChance + def.waveChance + def.accelChance) type = 'accel';
    else if (typeRoll < def.splitterChance + def.bouncerChance + def.waveChance + def.accelChance + def.spiralChance) type = 'spiral';
    else if (typeRoll < def.splitterChance + def.bouncerChance + def.waveChance + def.accelChance + def.spiralChance + def.clusterChance) type = 'cluster';
    else if (typeRoll < def.splitterChance + def.bouncerChance + def.waveChance + def.accelChance + def.spiralChance + def.clusterChance + def.mineChance) type = 'mine';

    let color = def.color;
    if (isHoming) color = '#ffaa00';
    else if (type === 'splitter') color = '#ff69b4';
    else if (type === 'bouncer') color = '#00ff88';
    else if (type === 'wave') color = '#a78bfa';
    else if (type === 'accel') color = '#ff4400';
    else if (type === 'spiral') color = '#00ffaa';
    else if (type === 'cluster') color = '#ff8800';
    else if (type === 'mine') color = '#ff0066';

    const opts = { homing: isHoming, type };
    if (type === 'cluster') opts.fuseTime = 0.8 + this.rng() * 0.4;
    if (type === 'mine') { opts.travelTime = 0.5; opts.dwellTime = 2.0 + this.rng() * 1.0; }
    const proj = new Projectile(
      warning.x, warning.y,
      (dx / dist) * speed, (dy / dist) * speed,
      color,
      opts
    );
    if (this._lastShotWasCounter) {
      proj.isCounter = true;
      this._lastShotWasCounter = false;
    }
    this.projectiles.push(proj);
    this.brain.onProjectileFired(this.gameTime * 1000);
  }

  _getEdgeTarget(edge) {
    const parts = edge.split('-');
    let x = this.w / 2, y = this.h / 2;
    for (const part of parts) {
      if (part === 'left') x = this.w * 0.15;
      if (part === 'right') x = this.w * 0.85;
      if (part === 'top') y = this.h * 0.15;
      if (part === 'bottom') y = this.h * 0.85;
    }
    return { x, y };
  }

  announceBoss() {
    soundEngine.playBossSpawn();
    this.bossLevel++;
    this.bossAnnounceTimer = BOSS_ANNOUNCE_DURATION / 1000;
    const bossType = BOSS_TYPES[(this.bossLevel - 1) % BOSS_TYPES.length];
    const el = document.getElementById('boss-announce');
    const titleEl = el.querySelector('.boss-title');
    titleEl.textContent = bossType.name.toUpperCase();
    titleEl.style.color = bossType.color;
    titleEl.style.textShadow = `0 0 40px ${bossType.color}99`;
    const bossTaunts = [
      'Oh this is gonna be fun. For me.',
      'You look nervous. Good instinct.',
      'It brought friends. Well, friend-shaped things.',
      'Remember that boss you barely survived? This one\'s worse.',
      'At this point you\'re just padding my kill count.',
    ];
    el.querySelector('.boss-sub').textContent =
      this.bossLevel === 1 ? 'Surprise! You didn\'t think this would be easy, right?' :
      bossTaunts[(this.bossLevel - 1) % bossTaunts.length];
    el.classList.add('show');
    setTimeout(() => {
      el.classList.remove('show');
      const edge = Math.floor(this.rng() * 4);
      let bx, by;
      switch (edge) {
        case 0: bx = this.rng() * this.w; by = -30; break;
        case 1: bx = this.w + 30; by = this.rng() * this.h; break;
        case 2: bx = this.rng() * this.w; by = this.h + 30; break;
        case 3: bx = -30; by = this.rng() * this.h; break;
      }
      this.bosses.push(new Boss(bx, by, this.w, this.h, this.bossLevel));
    }, BOSS_ANNOUNCE_DURATION);
  }

  bossDeathEffect(boss) {
    soundEngine.playBossKill();
    // Big explosion using boss color
    for (let i = 0; i < 40; i++) {
      const a = Math.random() * Math.PI * 2;
      const sp = 50 + Math.random() * 200;
      this.particles.push(new Particle(boss.x, boss.y, Math.cos(a) * sp, Math.sin(a) * sp, 0.8, boss.color, 3 + Math.random() * 3));
    }
    this.shockwaves.push(new Shockwave(boss.x, boss.y, boss.radius * 4, boss.color, 0.6));
    this.shockwaves.push(new Shockwave(boss.x, boss.y, boss.radius * 2.5, '#fff', 0.4));
  }

  announcePhase() {
    const def = PHASE_DEFS[this.phase];
    const el = document.getElementById('phase-announce');
    el.querySelector('.phase-num').textContent = `Phase ${this.phase + 1}`;
    el.querySelector('.phase-name').textContent = def.name;
    el.querySelector('.phase-name').style.color = def.color;
    el.querySelector('.phase-desc').textContent = def.desc;
    el.classList.add('show');
    this.phaseAnnounceTimer = PHASE_ANNOUNCE_DURATION / 1000;
    setTimeout(() => el.classList.remove('show'), PHASE_ANNOUNCE_DURATION);
  }

  die() {
    // Analytics: death event with phase info
    trackEvent(
      `death-phase-${this.phase + 1}`,
      `Died at ${this.gameTime.toFixed(1)}s in Phase ${this.phase + 1}: ${PHASE_DEFS[Math.min(this.phase, PHASE_DEFS.length - 1)].name}`
    );

    this.running = false;
    this.canvas.classList.remove('active');
    soundEngine.playDeath();
    soundEngine.stopMusic();
    document.getElementById('heat-bar-container').style.display = 'none';
    this.brain.lastThreatLevel = this.threatLevel;
    this.brain.save();
    this.totalGames++;
    localStorage.setItem('dodge-ai-games', this.totalGames.toString());

    // Check milestone unlocks for abilities
    const newUnlock = this.checkMilestoneUnlocks();
    if (newUnlock) {
      this.unlockAnnounce = { name: newUnlock, timer: 3.0 };
    }

    for (let i = 0; i < 50; i++) {
      const angle = Math.random() * Math.PI * 2;
      const speed = Math.random() * 250 + 50;
      this.particles.push(new Particle(
        this.player.x, this.player.y,
        Math.cos(angle) * speed, Math.sin(angle) * speed,
        0.8, '#00f0ff', Math.random() * 4 + 1
      ));
    }

    this.renderDeathFrame();

    const currentBests = loadBests();
    const currentBest = currentBests.length > 0 ? currentBests[0].time : 0;
    const isNewBest = this.gameTime > currentBest;
    if (isNewBest) {
      this.bestTime = this.gameTime;
      localStorage.setItem('dodge-ai-best', this.bestTime.toFixed(1));
    }
    saveBest(this.gameTime);

    // 300ms freeze with indicator, then 500ms particle fade, then game over
    setTimeout(() => this.startDeathParticles(), 300);
    setTimeout(() => this.showGameOver(isNewBest), 800);
  }

  renderDeathFrame() {
    // Freeze frame: dim the scene and show prominent death indicator
    const ctx = this.ctx;
    ctx.fillStyle = '#06060f';
    ctx.fillRect(0, 0, this.w, this.h);
    for (const p of this.projectiles) p.draw(ctx);
    for (const sw of this.shockwaves) sw.draw(ctx);
    // Dark overlay so indicator pops
    ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
    ctx.fillRect(0, 0, this.w, this.h);
    // Draw death indicator prominently on the frozen frame
    this.renderDeathIndicator(ctx);
  }

  startDeathParticles() {
    if (this.running) return;
    const ctx = this.ctx;
    const deathAnim = () => {
      if (this.running) return;
      ctx.fillStyle = 'rgba(6,6,15,0.15)';
      ctx.fillRect(0, 0, this.w, this.h);
      for (let i = this.particles.length - 1; i >= 0; i--) {
        this.particles[i].update(0.016);
        this.particles[i].draw(ctx);
        if (this.particles[i].life <= 0) this.particles.splice(i, 1);
      }
      for (let i = this.shockwaves.length - 1; i >= 0; i--) {
        this.shockwaves[i].update(0.016);
        this.shockwaves[i].draw(ctx);
        if (this.shockwaves[i].isDead()) this.shockwaves.splice(i, 1);
      }
      if (this.particles.length > 0 || this.shockwaves.length > 0) requestAnimationFrame(deathAnim);
    };
    requestAnimationFrame(deathAnim);
  }

  renderDeathIndicator(ctx) {
    if (!this.deathContext) return;
    const d = this.deathContext;

    ctx.save();

    // 1. Bright ring around the killer
    const ringRadius = d.type === 'boss' ? 40 : 22;
    ctx.strokeStyle = '#fff';
    ctx.lineWidth = 4;
    ctx.globalAlpha = 1;
    ctx.shadowColor = '#fff';
    ctx.shadowBlur = 12;
    ctx.beginPath();
    ctx.arc(d.x, d.y, ringRadius, 0, Math.PI * 2);
    ctx.stroke();
    ctx.shadowBlur = 0;

    // 2. Arrow line from player position to killer position
    ctx.strokeStyle = '#ff3355';
    ctx.lineWidth = 3;
    ctx.globalAlpha = 0.9;
    ctx.beginPath();
    ctx.moveTo(d.playerX, d.playerY);
    ctx.lineTo(d.x, d.y);
    ctx.stroke();

    // 3. Arrowhead at the killer end
    const headLen = 16;
    const spread = 0.4;
    const angle = d.angle;
    ctx.fillStyle = '#ff3355';
    ctx.globalAlpha = 0.9;
    ctx.beginPath();
    ctx.moveTo(d.x, d.y);
    ctx.lineTo(d.x - headLen * Math.cos(angle - spread), d.y - headLen * Math.sin(angle - spread));
    ctx.lineTo(d.x - headLen * Math.cos(angle + spread), d.y - headLen * Math.sin(angle + spread));
    ctx.closePath();
    ctx.fill();

    // 4. Label above the killer
    const label = d.bossName || d.subtype.toUpperCase();
    ctx.globalAlpha = 1;
    ctx.fillStyle = d.color;
    ctx.font = 'bold 14px Courier New';
    ctx.textAlign = 'center';
    ctx.shadowColor = d.color;
    ctx.shadowBlur = 8;
    ctx.fillText(label, d.x, d.y - ringRadius - 10);
    ctx.shadowBlur = 0;

    ctx.restore();
  }

  showGameOver(isNewBest) {
    // Clean up previous streak display
    const prevStreak = document.getElementById('go-streak');
    if (prevStreak) prevStreak.remove();

    document.getElementById('go-time').innerHTML = `${this.gameTime.toFixed(1)}<span>s</span>`;
    const phaseQuips = [
      'Died in Phase 1. The tutorial phase. I can\'t even.',
      'Phase 2. It was just getting warmed up.',
      'Phase 3. The AI predicted that, by the way.',
      'Phase 4. Your timing was... almost adequate.',
      'Phase 5. Respect. You earned that death.',
      'Phase 6. You absolute legend. Still dead though.',
    ];
    document.getElementById('go-phase').textContent = phaseQuips[Math.min(this.phase, 5)];
    document.getElementById('go-phase').style.color = '';
    document.getElementById('go-dodged').textContent = this.dodgedCount;
    // Streak tier in game over
    const killedByEl2 = document.getElementById('go-killed-by');
    if (this.streak.peakTierName) {
      killedByEl2.insertAdjacentHTML('afterend', `<div id="go-streak" style="color:${this.streak.peakTier >= 3 ? '#ff4400' : this.streak.peakTier >= 2 ? '#ff8800' : '#facc15'}; font-size:12px; letter-spacing:2px; margin-top:6px;">PEAK HEAT: ${this.streak.peakTierName}</div>`);
    }
    document.getElementById('go-closest').textContent = this.closestCall === Infinity ? '0px' : `${Math.round(this.closestCall)}px`;
    document.getElementById('go-games').textContent = this.totalGames;
    document.getElementById('go-new-best').style.display = isNewBest ? 'block' : 'none';

    const dom = this.brain.getDominantDodge();
    const reaction = this.brain.getAvgReaction();
    let learned = `I catalogued ${this.brain.totalSamples} of your panic moves.`;
    if (dom) learned += ` You dodge ${dom.direction} ${dom.pct}% of the time — real original.`;
    if (reaction) learned += ` ${reaction}ms reaction time. I've seen faster. I've seen slower. Both died.`;
    learned += ' Oh, and I remember everything for next round. Sweet dreams.';
    document.getElementById('go-ai-learned').textContent = learned;

    const killedByEl = document.getElementById('go-killed-by');
    if (this.deathContext) {
      const d = this.deathContext;
      const directionName = getDirectionName(d.angle);
      const killerName = d.bossName || d.subtype.toUpperCase();
      killedByEl.textContent = `Killed by: ${killerName} from the ${directionName}`;
      killedByEl.style.color = d.color;
      killedByEl.style.display = 'block';
    } else {
      killedByEl.style.display = 'none';
    }

    // Ability unlock announcement
    const unlockEl = document.getElementById('go-ability-unlock');
    if (unlockEl) {
      if (this.unlockAnnounce) {
        const abilityLabels = {
          dashBurst: 'DASH BURST', decoy: 'DECOY',
          phaseShift: 'PHASE SHIFT', timeWarp: 'TIME WARP'
        };
        unlockEl.textContent = `ABILITY UNLOCKED: ${abilityLabels[this.unlockAnnounce.name] || this.unlockAnnounce.name}`;
        unlockEl.style.display = 'block';
      } else {
        unlockEl.style.display = 'none';
      }
    }

    // Abilities progress
    const abilitiesEl = document.getElementById('go-abilities');
    if (abilitiesEl) {
      const unlockedCount = Object.values(this.abilities).filter(a => a.unlocked).length;
      if (unlockedCount > 0) {
        abilitiesEl.textContent = `Abilities: ${unlockedCount}/4 [SPACE to activate]`;
        abilitiesEl.style.display = 'block';
      } else {
        abilitiesEl.textContent = 'Abilities: Keep playing to unlock';
        abilitiesEl.style.display = 'block';
      }
    }

    // Hide mobile ability button on game over
    const abilityBtnEl = document.getElementById('ability-btn');
    if (abilityBtnEl) abilityBtnEl.style.display = 'none';

    document.getElementById('gameover-screen').classList.add('show');
    document.getElementById('ad-zone').style.display = 'flex';
    this.updateStartScreen();
  }

  generateShareCard() {
    const card = document.createElement('canvas');
    card.width = 1200;
    card.height = 630;
    const ctx = card.getContext('2d');

    // Background
    ctx.fillStyle = '#06060f';
    ctx.fillRect(0, 0, 1200, 630);

    // Subtle grid pattern (matches game aesthetic)
    ctx.strokeStyle = 'rgba(0, 240, 255, 0.03)';
    ctx.lineWidth = 1;
    for (let x = 0; x < 1200; x += 40) {
      ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, 630); ctx.stroke();
    }
    for (let y = 0; y < 630; y += 40) {
      ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(1200, y); ctx.stroke();
    }

    // Title: DODGE AI
    ctx.font = 'bold 42px "Courier New", monospace';
    ctx.fillStyle = '#00f0ff';
    ctx.textBaseline = 'top';
    ctx.fillText('DODGE AI', 60, 40);

    // AI confidence badge (top right)
    const confidence = this.brain.getConfidence();
    ctx.font = '20px "Courier New", monospace';
    ctx.fillStyle = '#ff3355';
    ctx.textAlign = 'right';
    ctx.fillText(`AI Confidence: ${confidence}%`, 1140, 48);
    ctx.textAlign = 'left';

    // Survival time (hero stat)
    ctx.font = 'bold 100px "Courier New", monospace';
    ctx.fillStyle = '#ffffff';
    ctx.fillText(`${this.gameTime.toFixed(1)}s`, 60, 110);

    // Phase reached
    const phaseName = PHASE_DEFS[Math.min(this.phase, PHASE_DEFS.length - 1)].name;
    ctx.font = 'bold 26px "Courier New", monospace';
    ctx.fillStyle = '#8b5cf6';
    ctx.fillText(`Phase ${this.phase + 1}: ${phaseName}`, 60, 230);

    // Divider line
    ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(60, 275);
    ctx.lineTo(1140, 275);
    ctx.stroke();

    // Stats row
    ctx.font = '20px "Courier New", monospace';
    ctx.fillStyle = '#888888';
    const closestStr = this.closestCall === Infinity ? '0px' : `${Math.round(this.closestCall)}px`;
    ctx.fillText(`Dodged: ${this.dodgedCount}`, 60, 300);
    ctx.fillText(`Closest Call: ${closestStr}`, 360, 300);
    ctx.fillText(`Games Played: ${this.totalGames}`, 700, 300);

    // AI commentary (the viral hook)
    const aiText = document.getElementById('go-ai-learned').textContent;
    ctx.font = 'italic 20px "Courier New", monospace';
    ctx.fillStyle = '#ff3355';

    // Word-wrap AI commentary to fit card width
    const maxWidth = 1080;
    const words = aiText.split(' ');
    let line = '';
    let y = 360;
    const lineHeight = 28;
    for (const word of words) {
      const testLine = line + (line ? ' ' : '') + word;
      if (ctx.measureText(testLine).width > maxWidth) {
        ctx.fillText(line, 60, y);
        line = word;
        y += lineHeight;
        if (y > 480) break; // Don't overflow
      } else {
        line = testLine;
      }
    }
    if (line && y <= 480) ctx.fillText(line, 60, y);

    // CTA at bottom
    ctx.font = '18px "Courier New", monospace';
    ctx.fillStyle = '#444444';
    ctx.fillText('Think you can survive longer?', 60, 580);

    return card;
  }

  share() {
    trackEvent('share-card-generated', 'Share Card Generated');

    // Generate visual card
    const card = this.generateShareCard();

    // Also prepare text for clipboard (secondary share option)
    const phase = PHASE_DEFS[this.phase].name;
    const emoji = this.phase >= 4 ? String.fromCodePoint(0x1F525) : this.phase >= 2 ? String.fromCodePoint(0x26A1) : String.fromCodePoint(0x1F3AF);
    const text = [
      `${emoji} DODGE AI \u2014 ${this.gameTime.toFixed(1)}s`,
      `Phase ${this.phase + 1}: ${phase}`,
      `Dodged: ${this.dodgedCount}`,
      this.bossesDefeated > 0 ? `Bosses demolished: ${this.bossesDefeated}` : '',
      `The AI thinks it knows me (${this.brain.getConfidence()}% confident)`,
      '',
      'Think you can last longer?',
    ].filter(Boolean).join('\n');

    // Convert card to blob and share
    card.toBlob(async (blob) => {
      if (!blob) {
        // Fallback to clipboard text if blob generation fails
        if (navigator.clipboard) navigator.clipboard.writeText(text).catch(() => {});
        return;
      }

      const file = new File([blob], 'dodge-ai-score.png', { type: 'image/png' });

      // Try native share (mobile-first)
      if (navigator.canShare && navigator.canShare({ files: [file] })) {
        try {
          await navigator.share({
            files: [file],
            title: 'DODGE AI',
            text: text
          });
          trackEvent('share-native', 'Shared via native dialog');
          return;
        } catch (e) {
          if (e.name === 'AbortError') return; // User cancelled
        }
      }

      // Fallback: download the image
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'dodge-ai-score.png';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      trackEvent('share-download', 'Shared via image download');

      // Also copy text to clipboard as secondary
      if (navigator.clipboard) navigator.clipboard.writeText(text).catch(() => {});
    }, 'image/png');
  }

  render() {
    const ctx = this.ctx;
    const w = this.w;
    const h = this.h;

    ctx.fillStyle = '#06060f';
    ctx.fillRect(0, 0, w, h);

    // Apply screen shake
    ctx.save();
    if (this.screenShake.intensity > 0) {
      ctx.translate(this.screenShake.x, this.screenShake.y);
    }

    // Slowmo tint
    if (this.effects.slowmo.active) {
      ctx.fillStyle = 'rgba(59, 130, 246, 0.04)';
      ctx.fillRect(0, 0, w, h);
    }

    // Grid
    ctx.strokeStyle = 'rgba(255,255,255,0.02)';
    ctx.lineWidth = 1;
    for (let x = 0; x < w; x += 50) { ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, h); ctx.stroke(); }
    for (let y = 0; y < h; y += 50) { ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(w, y); ctx.stroke(); }

    // Stars
    for (const star of this.bgStars) {
      ctx.globalAlpha = star.a * 0.3;
      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.arc(star.x, star.y, star.r, 0, Math.PI * 2);
      ctx.fill();
    }
    ctx.globalAlpha = 1;

    // Warnings
    const now = this.gameTime * 1000;
    for (const wr of this.warnings) wr.draw(ctx, now);

    // Power-ups
    for (const pu of this.powerups) pu.draw(ctx);

    // Shockwaves
    for (const sw of this.shockwaves) sw.draw(ctx);

    // Particles
    for (const p of this.particles) p.draw(ctx);

    // Projectiles
    for (const p of this.projectiles) p.draw(ctx);

    // Bosses
    for (const boss of this.bosses) boss.draw(ctx);

    // Decoy hologram
    if (this.decoyPos) {
      const alpha = 0.4 + Math.sin(this.decoyPos.age * 8) * 0.15;
      ctx.globalAlpha = alpha;
      ctx.strokeStyle = '#00ffaa';
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.arc(this.decoyPos.x, this.decoyPos.y, PLAYER_RADIUS, 0, Math.PI * 2);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(this.decoyPos.x - 5, this.decoyPos.y);
      ctx.lineTo(this.decoyPos.x + 5, this.decoyPos.y);
      ctx.moveTo(this.decoyPos.x, this.decoyPos.y - 5);
      ctx.lineTo(this.decoyPos.x, this.decoyPos.y + 5);
      ctx.stroke();
      ctx.globalAlpha = 1;
    }

    // Player
    if (this.running) {
      const pr = this.getPlayerRadius();
      const playerColor = this.effects.shrink.active ? '#ec4899' : '#00f0ff';

      // Magnet repel ring
      if (this.effects.magnet.active) {
        const repelAlpha = 0.12 + Math.sin(this.gameTime * 10) * 0.06;
        ctx.globalAlpha = repelAlpha;
        ctx.strokeStyle = '#f97316';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(this.player.x, this.player.y, 150, 0, Math.PI * 2);
        ctx.stroke();
        // Inner pulsing ring
        const innerR = 150 - Math.sin(this.gameTime * 8) * 30;
        ctx.globalAlpha = repelAlpha * 0.5;
        ctx.beginPath();
        ctx.arc(this.player.x, this.player.y, innerR, 0, Math.PI * 2);
        ctx.stroke();
        ctx.globalAlpha = 1;
      }

      // === BLACK HOLE (Interstellar-style) ===
      if (this.effects.vortex.active) {
        const vx = this.effects.vortex.x;
        const vy = this.effects.vortex.y;
        const totalDur = this.effects.vortex.duration;
        const rem = this.effects.vortex.remaining;
        const delay = this.effects.vortex.delay;
        const gt = this.gameTime;

        ctx.save();

        if (delay > 0) {
          // --- FORMING PHASE: warning ripple + growing singularity ---
          const formProgress = 1 - (delay / 1.5); // 0 -> 1 over 1.5s
          const warningR = 40 * formProgress;

          // Pulsing warning rings expanding outward
          for (let r = 0; r < 3; r++) {
            const ringPhase = (formProgress * 3 + r * 0.33) % 1;
            const ringR = ringPhase * 120;
            ctx.globalAlpha = (1 - ringPhase) * 0.3 * formProgress;
            ctx.strokeStyle = '#a855f7';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(vx, vy, ringR, 0, Math.PI * 2);
            ctx.stroke();
          }

          // Growing dark core
          ctx.globalAlpha = formProgress * 0.8;
          const formGrad = ctx.createRadialGradient(vx, vy, 0, vx, vy, warningR);
          formGrad.addColorStop(0, '#000');
          formGrad.addColorStop(0.6, 'rgba(88, 28, 135, 0.6)');
          formGrad.addColorStop(1, 'rgba(168, 85, 247, 0)');
          ctx.fillStyle = formGrad;
          ctx.beginPath();
          ctx.arc(vx, vy, warningR, 0, Math.PI * 2);
          ctx.fill();

          // Flickering sparks converging
          for (let i = 0; i < 8; i++) {
            const a = (i / 8) * Math.PI * 2 + gt * 4;
            const sparkR = (1 - formProgress) * 80 + 10;
            ctx.globalAlpha = 0.5 * formProgress;
            ctx.fillStyle = '#c084fc';
            ctx.beginPath();
            ctx.arc(vx + Math.cos(a) * sparkR, vy + Math.sin(a) * sparkR, 2, 0, Math.PI * 2);
            ctx.fill();
          }

        } else {
          // --- ACTIVE BLACK HOLE ---
          const activeDur = totalDur - 1.5;
          const activeRem = rem;
          const life = Math.min(1, activeRem / (activeDur * 0.8)); // fade in last 20%
          const baseR = 40;
          const pulse = 1 + Math.sin(gt * 3) * 0.05;
          const coreR = baseR * pulse;

          // Gravitational lensing glow (outermost halo)
          const lensR = coreR * 6;
          const lensGrad = ctx.createRadialGradient(vx, vy, coreR * 2, vx, vy, lensR);
          lensGrad.addColorStop(0, 'rgba(168, 85, 247, 0.15)');
          lensGrad.addColorStop(0.3, 'rgba(251, 146, 60, 0.08)');
          lensGrad.addColorStop(1, 'rgba(168, 85, 247, 0)');
          ctx.globalAlpha = life;
          ctx.fillStyle = lensGrad;
          ctx.beginPath();
          ctx.arc(vx, vy, lensR, 0, Math.PI * 2);
          ctx.fill();

          // Accretion disk — tilted ellipse with rotation
          const diskR = coreR * 3.5;
          const diskRotation = gt * 0.8;
          const diskTilt = 0.28;

          // Outer accretion glow rings
          for (let ring = 4; ring >= 0; ring--) {
            const rr = diskR + ring * 8;
            const alpha = (0.3 - ring * 0.05) * life;
            const hue = 20 + ring * 12;
            ctx.globalAlpha = alpha;
            ctx.strokeStyle = `hsl(${hue}, 95%, ${58 + ring * 7}%)`;
            ctx.lineWidth = 5 - ring * 0.6;
            ctx.beginPath();
            ctx.ellipse(vx, vy, rr, rr * diskTilt, diskRotation, 0, Math.PI * 2);
            ctx.stroke();
          }

          // Hot inner accretion disk
          ctx.globalAlpha = 0.8 * life;
          ctx.strokeStyle = '#fff';
          ctx.lineWidth = 2.5;
          ctx.beginPath();
          ctx.ellipse(vx, vy, diskR * 0.7, diskR * 0.7 * diskTilt, diskRotation, 0, Math.PI * 2);
          ctx.stroke();
          ctx.strokeStyle = '#fb923c';
          ctx.lineWidth = 4;
          ctx.beginPath();
          ctx.ellipse(vx, vy, diskR * 0.85, diskR * 0.85 * diskTilt, diskRotation, 0, Math.PI * 2);
          ctx.stroke();

          // Perpendicular cross-disk (vertical ring from Interstellar)
          ctx.globalAlpha = 0.18 * life;
          ctx.strokeStyle = '#c084fc';
          ctx.lineWidth = 3;
          ctx.beginPath();
          ctx.ellipse(vx, vy, diskR * 0.6, diskR, diskRotation, 0, Math.PI * 2);
          ctx.stroke();

          // Event horizon (pitch black center)
          ctx.globalAlpha = 1;
          const bhGrad = ctx.createRadialGradient(vx, vy, 0, vx, vy, coreR * 1.3);
          bhGrad.addColorStop(0, '#000');
          bhGrad.addColorStop(0.7, '#000');
          bhGrad.addColorStop(1, 'rgba(88, 28, 135, 0.8)');
          ctx.fillStyle = bhGrad;
          ctx.beginPath();
          ctx.arc(vx, vy, coreR * 1.3, 0, Math.PI * 2);
          ctx.fill();

          // Photon ring
          ctx.globalAlpha = (0.7 + Math.sin(gt * 12) * 0.2) * life;
          ctx.strokeStyle = '#fbbf24';
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.arc(vx, vy, coreR * 1.35, 0, Math.PI * 2);
          ctx.stroke();

          // Orbiting debris particles
          for (let i = 0; i < 24; i++) {
            const angle = (i / 24) * Math.PI * 2 + gt * (1.2 + i * 0.12);
            const orbitR = coreR * 2 + Math.sin(gt * 2 + i) * 12;
            const squash = 0.25 + Math.abs(Math.sin(angle + diskRotation)) * 0.75;
            const px = vx + Math.cos(angle) * orbitR;
            const py = vy + Math.sin(angle) * orbitR * squash;
            const brightness = 0.3 + Math.abs(Math.sin(angle * 2 + gt)) * 0.7;
            ctx.globalAlpha = brightness * 0.7 * life;
            ctx.fillStyle = brightness > 0.6 ? '#fbbf24' : '#fb923c';
            ctx.beginPath();
            ctx.arc(px, py, 2, 0, Math.PI * 2);
            ctx.fill();
          }
        }

        ctx.restore();
      }

      // Time Warp screen tint
      if (this.abilities.timeWarp.active) {
        ctx.fillStyle = 'rgba(0, 255, 170, 0.03)';
        ctx.fillRect(0, 0, w, h);
      }

      // Phase Shift transparency
      let ghostAlpha = this.abilities.phaseShift.active ? 0.35 : 1;

      // Outer glow
      ctx.shadowColor = playerColor;
      ctx.shadowBlur = 25;
      ctx.globalAlpha = 0.15 * ghostAlpha;
      ctx.fillStyle = playerColor;
      ctx.beginPath();
      ctx.arc(this.player.x, this.player.y, pr + 6, 0, Math.PI * 2);
      ctx.fill();

      // Core
      ctx.globalAlpha = ghostAlpha;
      ctx.fillStyle = playerColor;
      ctx.beginPath();
      ctx.arc(this.player.x, this.player.y, pr, 0, Math.PI * 2);
      ctx.fill();

      // Inner
      ctx.globalAlpha = ghostAlpha;
      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.arc(this.player.x, this.player.y, pr * 0.4, 0, Math.PI * 2);
      ctx.fill();
      ctx.shadowBlur = 0;
      ctx.globalAlpha = 1;

      // Streak visual effects
      if (this.streak.tier >= 1) {
        // WARM: golden glow around player
        const glowAlpha = 0.08 + this.streak.tier * 0.04;
        const glowR = pr + 10 + this.streak.tier * 8;
        ctx.globalAlpha = glowAlpha;
        const heatGrad = ctx.createRadialGradient(this.player.x, this.player.y, pr, this.player.x, this.player.y, glowR);
        const heatColors = ['rgba(250,204,21,0.3)', 'rgba(250,204,21,0)'];
        if (this.streak.tier >= 3) {
          heatColors[0] = 'rgba(255,68,0,0.3)';
        } else if (this.streak.tier >= 2) {
          heatColors[0] = 'rgba(249,115,22,0.3)';
        }
        heatGrad.addColorStop(0, heatColors[0]);
        heatGrad.addColorStop(1, heatColors[1]);
        ctx.fillStyle = heatGrad;
        ctx.beginPath();
        ctx.arc(this.player.x, this.player.y, glowR, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1;
      }

      if (this.streak.tier >= 3) {
        // ON FIRE: screen edge flame effect
        const edgeAlpha = 0.04 + (this.streak.tier === 4 ? 0.03 : 0);
        const pulse = Math.sin(this.gameTime * 4) * 0.02;
        ctx.globalAlpha = edgeAlpha + pulse;
        const edgeGrad = ctx.createRadialGradient(w/2, h/2, Math.min(w,h)*0.3, w/2, h/2, Math.min(w,h)*0.7);
        edgeGrad.addColorStop(0, 'rgba(255,68,0,0)');
        edgeGrad.addColorStop(1, 'rgba(255,68,0,0.6)');
        ctx.fillStyle = edgeGrad;
        ctx.fillRect(0, 0, w, h);
        ctx.globalAlpha = 1;
      }

      // Mobile ability button visibility update
      const abilityBtnEl = document.getElementById('ability-btn');
      if (abilityBtnEl) {
        const hasAbility = Object.values(this.abilities).some(a => a.unlocked);
        const isMobile = 'ontouchstart' in window;
        abilityBtnEl.style.display = (isMobile && hasAbility && this.running) ? 'block' : 'none';
        if (hasAbility) {
          const abilityOrder = ['dashBurst', 'decoy', 'phaseShift', 'timeWarp'];
          const ready = abilityOrder.find(n => this.abilities[n].unlocked && this.abilities[n].cooldown <= 0 && !this.abilities[n].active);
          if (ready) {
            const labels = { dashBurst: 'DB', decoy: 'DC', phaseShift: 'PS', timeWarp: 'TW' };
            abilityBtnEl.textContent = labels[ready] || 'AB';
            abilityBtnEl.style.borderColor = 'rgba(0, 255, 170, 0.6)';
          } else {
            const minCd = Math.min(...Object.values(this.abilities).filter(a => a.unlocked).map(a => a.cooldown > 0 ? a.cooldown : 999));
            abilityBtnEl.textContent = minCd < 999 ? Math.ceil(minCd) : '--';
            abilityBtnEl.style.borderColor = 'rgba(0, 255, 170, 0.2)';
          }
        }
      }
    }

    // Restore screen shake translation
    ctx.restore();

    // Screen flash overlay (drawn AFTER ctx.restore so it covers full screen)
    if (this.flashAlpha > 0) {
      ctx.globalAlpha = this.flashAlpha;
      ctx.fillStyle = this.flashColor;
      ctx.fillRect(0, 0, w, h);
      ctx.globalAlpha = 1;
    }
  }

  updateThreatLevel(dt) {
    const maxRatePerSecond = 0.015;

    // Session cap: ramps from 0.3 to 1.0 over 120 seconds (smoother curve)
    const sessionCap = Math.min(1.0, 0.3 + (this.gameTime / 120) * 0.7);

    // Rise based on AI confidence and active pattern count
    const gameTimeSec = this.gameTime;
    const confidence = this.brain.getConfidence() / 100;
    const activePatterns = this.brain.getActivePatternCount(gameTimeSec);
    const riseRate = (confidence * 0.008 + activePatterns * 0.003) * dt;

    // Decay when counter-pattern shots are dodged
    let decayRate = 0;
    if (this.recentCounterMisses > 2) {
      decayRate = 0.004 * dt;
      this.recentCounterMisses = Math.max(0, this.recentCounterMisses - dt * 0.5);
    }

    // Apply with rate limit and session cap
    const netChange = Math.min(riseRate, maxRatePerSecond * dt) - decayRate;
    this.threatLevel = Math.min(sessionCap, Math.max(0, this.threatLevel + netChange));
  }

  updateEndgameCycle(dt) {
    if (this.threatLevel < 0.9) {
      this._threatAtCapDuration = 0;
      this.endgameMode = null;
      return;
    }

    this._threatAtCapDuration += dt;

    // Start cycling after 5 seconds at max threat
    if (this._threatAtCapDuration < 5) return;

    this.endgameCycleTimer += dt;
    const cycleDuration = 12;
    const modeIndex = Math.floor(this.endgameCycleTimer / cycleDuration) % 3;
    const modes = ['zone-denial', 'prediction-spam', 'speed-pressure'];
    const newMode = modes[modeIndex];

    if (newMode !== this.endgameMode) {
      this.endgameMode = newMode;
    }
  }

  updateUI() {
    document.getElementById('hud-time').textContent = `${this.gameTime.toFixed(1)}s`;
    const def = PHASE_DEFS[this.phase];
    const phaseEl = document.getElementById('hud-phase');
    phaseEl.textContent = `PHASE ${this.phase + 1} — ${def.name}`;
    phaseEl.style.color = def.color;
    document.getElementById('hud-dodged').textContent = `Dodged: ${this.dodgedCount}`;

    document.getElementById('brain-confidence').textContent = `${this.brain.getConfidence()}%`;
    document.getElementById('brain-threat').textContent = `${Math.round((this.threatLevel || 0) * 100)}%`;
    document.getElementById('brain-patterns').textContent = this.brain.getActivePatternCount(this.gameTime);
    const reaction = this.brain.getAvgReaction();
    document.getElementById('brain-reaction').textContent = reaction ? `${reaction}ms` : '—';
    document.getElementById('brain-samples').textContent = this.brain.totalSamples;
    const bias = this.brain.getBiasPercentages();
    document.getElementById('bias-up').textContent = `${bias.up}%`;
    document.getElementById('bias-down').textContent = `${bias.down}%`;
    document.getElementById('bias-left').textContent = `${bias.left}%`;
    document.getElementById('bias-right').textContent = `${bias.right}%`;
    document.getElementById('brain-insight').textContent = this.brain.getInsight();

    // Heat bar
    const heatFill = document.getElementById('heat-bar-fill');
    const heatTier = document.getElementById('heat-tier');
    if (heatFill) {
      heatFill.style.width = `${this.streak.heat}%`;
      if (this.streak.heat >= 75) { heatFill.style.background = '#ff3355'; }
      else if (this.streak.heat >= 50) { heatFill.style.background = '#ff8800'; }
      else if (this.streak.heat >= 25) { heatFill.style.background = '#facc15'; }
      else { heatFill.style.background = '#3b82f6'; }
    }
    if (heatTier) {
      heatTier.textContent = this.streak.tierName;
      const tierColors = { '': '#666', 'WARM': '#facc15', 'HOT': '#ff8800', 'ON FIRE': '#ff4400', 'UNSTOPPABLE': '#ff3355' };
      heatTier.style.color = tierColors[this.streak.tierName] || '#666';
    }

    for (const key of ['slowmo', 'shrink', 'magnet', 'vortex']) {
      const eff = this.effects[key];
      const el = document.getElementById(`pu-${key}`);
      const bar = document.getElementById(`pu-${key}-bar`);
      if (el && bar) {
        if (eff.active) {
          el.classList.add('active');
          bar.style.width = `${(eff.remaining / eff.duration) * 100}%`;
        } else {
          el.classList.remove('active');
        }
      }
    }
  }

}

// Analytics: session tracking
let _sessionGamesPlayed = 0;
let _gameEverStarted = false;

// Track page load (fires when GoatCounter loads, or on next available moment)
// Compare page-load count vs game-start count in dashboard to get pre-play drop-off
function _initAnalytics() {
  trackEvent('page-load', 'Page Loaded');
}
// GoatCounter loads async; poll briefly to fire page-load event
(function() {
  let attempts = 0;
  const interval = setInterval(() => {
    attempts++;
    if (window.goatcounter && window.goatcounter.count) {
      _initAnalytics();
      clearInterval(interval);
    } else if (attempts > 20) {
      clearInterval(interval); // Give up after ~10 seconds
    }
  }, 500);
})();

// Track session depth on page unload (best-effort)
window.addEventListener('beforeunload', () => {
  if (_sessionGamesPlayed > 0) {
    trackEvent(`session-games-${Math.min(_sessionGamesPlayed, 10)}`,
      `Session ended after ${_sessionGamesPlayed} games`);
  }
});

// Boot
const game = new Game();
window._game = game;
</script>
<!-- Analytics: GoatCounter (privacy-first, no cookies) -->
<script data-goatcounter="https://DODGEAI.goatcounter.com/count"
        async src="//gc.zgo.at/count.js"></script>
</body>
</html>
