---
phase: 05-new-mechanics
plan: 03
type: execute
wave: 3
depends_on: [05-02]
files_modified: [index.html]
autonomous: true

must_haves:
  truths:
    - "Players unlock abilities by reaching survival milestones (total time survived, single-run records)"
    - "Dash Burst teleports the player in movement direction with brief invulnerability and shockwave"
    - "Decoy drops a holographic copy that attracts homing projectiles and AI targeting for 3 seconds"
    - "Phase Shift makes projectiles pass through the player but hazards still hurt"
    - "Time Warp slows all projectiles to 30% speed but also slows the player to 70%"
    - "Abilities have cooldown timers (10-20s) and a visible cooldown indicator near the player"
    - "Unlocked abilities persist across sessions in localStorage"
    - "Spacebar activates ability on desktop; dedicated button on mobile"
  artifacts:
    - path: "index.html"
      provides: "4 unlockable abilities with cooldown system, milestone tracking, and persistence"
      contains: "dodge-ai-abilities"
  key_links:
    - from: "localStorage dodge-ai-abilities"
      to: "Game.abilities"
      via: "loadAbilities() on game start"
      pattern: "loadAbilities"
    - from: "Game.checkMilestoneUnlocks"
      to: "localStorage dodge-ai-abilities"
      via: "threshold checks after each game"
      pattern: "checkMilestoneUnlocks"
    - from: "spacebar/button input"
      to: "Game.activateAbility"
      via: "keydown handler and mobile button tap"
      pattern: "activateAbility"
---

<objective>
Add 4 unlockable player abilities (Dash Burst, Decoy, Phase Shift, Time Warp) with cooldown-based activation, milestone unlock system, and localStorage persistence.

Purpose: Abilities give players earned mastery tools that change HOW they play, creating progression incentive beyond high scores. Abilities are a SEPARATE system from powerups (powerups = luck, abilities = skill). This fulfills MECH-03.

Output: index.html with 4 abilities, milestone tracking, persistence in dodge-ai-abilities localStorage key, spacebar/button activation, and cooldown HUD indicator.
</objective>

<execution_context>
@C:\Users\Zahi\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\Zahi\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-new-mechanics/05-RESEARCH.md
@.planning/phases/05-new-mechanics/05-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add ability system with unlock thresholds, persistence, activation logic, and cooldown timers</name>
  <files>index.html</files>
  <action>
1. In Game constructor (near the effects object, ~line 2321), add ability state:
   ```javascript
   this.abilities = {
     dashBurst:  { unlocked: false, cooldown: 0, maxCooldown: 10, duration: 0.3, active: false, remaining: 0 },
     decoy:      { unlocked: false, cooldown: 0, maxCooldown: 12, duration: 3.0, active: false, remaining: 0 },
     phaseShift: { unlocked: false, cooldown: 0, maxCooldown: 15, duration: 0.5, active: false, remaining: 0 },
     timeWarp:   { unlocked: false, cooldown: 0, maxCooldown: 20, duration: 2.0, active: false, remaining: 0 },
   };
   this.activeAbility = null; // Currently active ability name
   this.decoyPos = null;      // Decoy hologram position {x, y, age}
   this.milestones = { totalTimeSurvived: 0 };
   ```

2. Add loadAbilities() method to Game class:
   ```javascript
   loadAbilities() {
     try {
       const data = JSON.parse(localStorage.getItem('dodge-ai-abilities'));
       if (data) {
         if (data.unlocked) {
           for (const name of data.unlocked) {
             if (this.abilities[name]) this.abilities[name].unlocked = true;
           }
         }
         if (data.milestones) {
           this.milestones = { ...this.milestones, ...data.milestones };
         }
       }
     } catch (e) {}
   }
   ```

3. Add saveAbilities() method:
   ```javascript
   saveAbilities() {
     const unlocked = Object.keys(this.abilities).filter(k => this.abilities[k].unlocked);
     localStorage.setItem('dodge-ai-abilities', JSON.stringify({
       unlocked,
       milestones: this.milestones,
       version: 1
     }));
   }
   ```

4. Add checkMilestoneUnlocks() method -- called after each game ends (in die() or game-over):
   ```javascript
   checkMilestoneUnlocks() {
     this.milestones.totalTimeSurvived += this.gameTime;
     const bestRun = this.bestTime;
     const total = this.milestones.totalTimeSurvived;
     const thresholds = {
       dashBurst:  { totalTime: 300 },   // ~5min total play
       decoy:      { totalTime: 900 },   // ~15min total play
       phaseShift: { bestRun: 60 },      // Survived to Phase 4 once
       timeWarp:   { totalTime: 2400 },  // ~40min total play
     };
     let newUnlock = null;
     for (const [name, req] of Object.entries(thresholds)) {
       if (this.abilities[name].unlocked) continue;
       const met = (!req.totalTime || total >= req.totalTime) &&
                   (!req.bestRun || bestRun >= req.bestRun);
       if (met) {
         this.abilities[name].unlocked = true;
         newUnlock = name;
       }
     }
     this.saveAbilities();
     return newUnlock; // For potential unlock announcement
   }
   ```

5. Add activateAbility() method:
   ```javascript
   activateAbility() {
     if (this.state !== 'playing') return;
     // Find first unlocked ability off cooldown
     const order = ['dashBurst', 'decoy', 'phaseShift', 'timeWarp'];
     const available = order.find(name => {
       const a = this.abilities[name];
       return a.unlocked && a.cooldown <= 0 && !a.active;
     });
     if (!available) return;

     const ability = this.abilities[available];
     ability.active = true;
     ability.remaining = ability.duration;
     ability.cooldown = ability.maxCooldown;
     this.activeAbility = available;

     // Per-ability activation effects
     if (available === 'dashBurst') {
       // Teleport 100px in movement direction + shockwave
       const speed = Math.sqrt(this.player.vx * this.player.vx + this.player.vy * this.player.vy);
       if (speed > 0.1) {
         this.player.x += (this.player.vx / speed) * 100;
         this.player.y += (this.player.vy / speed) * 100;
       } else {
         this.player.y -= 100; // Default: dash upward
       }
       // Clamp to arena bounds
       this.player.x = Math.max(10, Math.min(this.w - 10, this.player.x));
       this.player.y = Math.max(10, Math.min(this.h - 10, this.player.y));
       // Push nearby projectiles away (reuse shockwave logic)
       for (const p of this.projectiles) {
         const dx = p.x - this.player.x;
         const dy = p.y - this.player.y;
         const dist = Math.sqrt(dx * dx + dy * dy);
         if (dist < 80 && dist > 0) {
           const push = 3;
           p.vx += (dx / dist) * push;
           p.vy += (dy / dist) * push;
         }
       }
       // Visual: create shockwave particle
       this.particles.push(new Particle(this.player.x, this.player.y, '#00ffaa', 'shockwave'));
     }

     else if (available === 'decoy') {
       // Drop holographic copy at current position
       this.decoyPos = { x: this.player.x, y: this.player.y, age: 0 };
     }

     // phaseShift and timeWarp are continuous effects handled in update()
   }
   ```

6. Call loadAbilities() at end of Game constructor (after this.setupInput()).

7. Call checkMilestoneUnlocks() in die() method (line ~3365 area, after totalGames++ and before game-over rendering).

8. In Game.update(), add ability cooldown/duration management:
   ```javascript
   // Update ability cooldowns and active durations
   for (const [name, a] of Object.entries(this.abilities)) {
     if (a.cooldown > 0) a.cooldown -= dt;
     if (a.active) {
       a.remaining -= dt;
       if (a.remaining <= 0) {
         a.active = false;
         a.remaining = 0;
         if (this.activeAbility === name) this.activeAbility = null;
         if (name === 'decoy') this.decoyPos = null;
       }
     }
   }

   // Decoy: attract homing projectiles toward decoy instead of player
   if (this.decoyPos) {
     this.decoyPos.age += dt;
     for (const p of this.projectiles) {
       if (p.homing && p.age < 3) {
         // Redirect homing toward decoy
         const dx = this.decoyPos.x - p.x;
         const dy = this.decoyPos.y - p.y;
         const dist = Math.sqrt(dx * dx + dy * dy) || 1;
         p.vx += (dx / dist) * p.homingStrength * 60 * dt * 0.7;
         p.vy += (dy / dist) * p.homingStrength * 60 * dt * 0.7;
       }
     }
   }

   // Phase Shift: projectiles pass through (skip collision check)
   // Handled by wrapping the collision detection with a phaseShift check

   // Time Warp: slow projectiles to 30%, player to 70%
   // Handled by modifying slowMod in the update calculations
   ```

9. For Phase Shift collision immunity: In the projectile-player collision check (around line ~2994 area where sorted projectiles are checked), add:
   ```javascript
   if (this.abilities.phaseShift.active) continue; // Projectiles pass through during Phase Shift
   ```
   IMPORTANT: Phase Shift does NOT protect from hazard damage (the danger-zone and arena-shrink checks in 05-02 should NOT check for phaseShift). This is the tradeoff: projectile immunity but hazard vulnerability.

10. For Time Warp slowdown: In the projectile update section where `slowMod` is computed, when timeWarp is active multiply the slow modifier by 0.3. Also reduce player lerp speed to 70% during timeWarp.

11. In Game.reset(), reset all ability active states and cooldowns (but NOT unlocked status):
    ```javascript
    for (const a of Object.values(this.abilities)) {
      a.cooldown = 0; a.active = false; a.remaining = 0;
    }
    this.activeAbility = null;
    this.decoyPos = null;
    ```

CRITICAL: Ability cooldowns must use real time (dt), NOT this.rng(). Ability activation uses Math.random() for any cosmetic effects. This preserves daily challenge seed determinism -- abilities are player-triggered, not spawn-system events.
  </action>
  <verify>
In browser console after loading:
1. `_game.abilities` shows all 4 abilities with unlocked: false
2. `localStorage.setItem('dodge-ai-abilities', JSON.stringify({unlocked:['dashBurst'],milestones:{totalTimeSurvived:300},version:1}))` then refresh -- dashBurst shows unlocked: true
3. Clear localStorage, play and die -- `_game.milestones.totalTimeSurvived` increases
  </verify>
  <done>4 abilities (dashBurst, decoy, phaseShift, timeWarp) with cooldown timers, milestone-based unlocking, localStorage persistence, activation effects, and game integration (collision immunity for phaseShift, slow modifier for timeWarp, homing redirect for decoy, teleport+shockwave for dashBurst).</done>
</task>

<task type="auto">
  <name>Task 2: Add ability input handlers (spacebar/button), cooldown HUD indicator, unlock notification, and game-over display</name>
  <files>index.html</files>
  <action>
1. In setupInput() method, add spacebar handler for ability activation:
   ```javascript
   // Inside the existing keydown handler (search for 'keydown')
   if (e.code === 'Space' && this.state === 'playing') {
     e.preventDefault();
     this.activateAbility();
   }
   ```
   Make sure this doesn't conflict with any existing Space key binding. Check existing keydown handler first -- if Space is already used, find the right insertion point.

2. Add mobile ability button. In the HTML (or dynamically created in Game constructor), add a fixed-position button:
   ```html
   <button id="ability-btn" style="
     position: fixed; bottom: 80px; right: 20px;
     width: 50px; height: 50px; border-radius: 50%;
     background: rgba(0, 255, 170, 0.15); border: 2px solid rgba(0, 255, 170, 0.4);
     color: #00ffaa; font-size: 18px; font-weight: bold;
     display: none; z-index: 100; touch-action: manipulation;
     font-family: monospace;
   ">AB</button>
   ```
   Show this button only on touch devices (detect via 'ontouchstart' in window) AND only when at least one ability is unlocked. The button text shows the first letter of the ready ability, or a cooldown number.

3. Wire up the mobile button:
   ```javascript
   document.getElementById('ability-btn').addEventListener('touchstart', (e) => {
     e.preventDefault();
     this.activateAbility();
   });
   ```

4. In Game.render() (during gameplay), draw a cooldown indicator near the player:
   ```javascript
   // Ability cooldown ring near player
   const readyAbility = ['dashBurst', 'decoy', 'phaseShift', 'timeWarp']
     .find(n => this.abilities[n].unlocked);
   if (readyAbility) {
     const a = this.abilities[readyAbility];
     const ringX = this.player.x + 15;
     const ringY = this.player.y - 15;
     const ringRadius = 6;

     if (a.cooldown > 0) {
       // Show cooldown arc (thin, subtle)
       const progress = 1 - (a.cooldown / a.maxCooldown);
       ctx.strokeStyle = 'rgba(0, 255, 170, 0.3)';
       ctx.lineWidth = 2;
       ctx.beginPath();
       ctx.arc(ringX, ringY, ringRadius, -Math.PI / 2, -Math.PI / 2 + progress * Math.PI * 2);
       ctx.stroke();
     } else if (!a.active) {
       // Ready indicator: solid small ring
       ctx.strokeStyle = 'rgba(0, 255, 170, 0.6)';
       ctx.lineWidth = 2;
       ctx.beginPath();
       ctx.arc(ringX, ringY, ringRadius, 0, Math.PI * 2);
       ctx.stroke();
     }
   }
   ```
   This is a minimal ring that follows the player. It disappears when the ability is active (no persistent UI clutter).

5. Draw decoy hologram when active:
   ```javascript
   if (this.decoyPos) {
     const alpha = 0.4 + Math.sin(this.decoyPos.age * 8) * 0.15;
     ctx.globalAlpha = alpha;
     ctx.strokeStyle = '#00ffaa';
     ctx.lineWidth = 1.5;
     ctx.beginPath();
     ctx.arc(this.decoyPos.x, this.decoyPos.y, PLAYER_RADIUS, 0, Math.PI * 2);
     ctx.stroke();
     // Draw cross inside to distinguish from real player
     ctx.beginPath();
     ctx.moveTo(this.decoyPos.x - 5, this.decoyPos.y);
     ctx.lineTo(this.decoyPos.x + 5, this.decoyPos.y);
     ctx.moveTo(this.decoyPos.x, this.decoyPos.y - 5);
     ctx.lineTo(this.decoyPos.x, this.decoyPos.y + 5);
     ctx.stroke();
     ctx.globalAlpha = 1;
   }
   ```

6. Draw Phase Shift visual effect on player when active:
   ```javascript
   if (this.abilities.phaseShift.active) {
     ctx.globalAlpha = 0.35; // Player becomes translucent
     // The existing player draw will pick up the alpha
   }
   ```
   Apply this globalAlpha BEFORE the player draw call, then reset to 1 after.

7. Unlock notification: When checkMilestoneUnlocks() returns a new unlock name, show a brief announcement using the existing phase-announce pattern (or a simpler approach):
   ```javascript
   // In die() after checkMilestoneUnlocks():
   const newUnlock = this.checkMilestoneUnlocks();
   if (newUnlock) {
     this.unlockAnnounce = { name: newUnlock, timer: 3.0 };
   }
   ```
   In the game-over render, if `this.unlockAnnounce` exists and timer > 0, draw:
   ```
   "ABILITY UNLOCKED: DASH BURST" (in mint green, centered)
   ```
   Decrement timer in the game-over update loop.

8. In game-over stats display (around line ~3514 area or stats modal), show unlocked abilities count:
   ```javascript
   const unlockedCount = Object.values(this.abilities).filter(a => a.unlocked).length;
   // Add to stats: "Abilities: 2/4" or similar
   ```

9. Update the mobile ability button visibility in the render loop or on game state change:
   ```javascript
   const abilityBtn = document.getElementById('ability-btn');
   if (abilityBtn) {
     const hasAbility = Object.values(this.abilities).some(a => a.unlocked);
     const isMobile = 'ontouchstart' in window;
     abilityBtn.style.display = (isMobile && hasAbility && this.state === 'playing') ? 'block' : 'none';
     if (hasAbility) {
       const ready = ['dashBurst', 'decoy', 'phaseShift', 'timeWarp']
         .find(n => this.abilities[n].unlocked && this.abilities[n].cooldown <= 0);
       abilityBtn.textContent = ready ? ready[0].toUpperCase() : Math.ceil(
         Math.min(...Object.values(this.abilities).filter(a => a.unlocked).map(a => a.cooldown))
       );
     }
   }
   ```
  </action>
  <verify>
1. Open in browser, set localStorage to unlock dashBurst: `localStorage.setItem('dodge-ai-abilities', JSON.stringify({unlocked:['dashBurst'],milestones:{totalTimeSurvived:300},version:1}))`
2. Refresh, start game, press Space -- player teleports in movement direction with shockwave
3. Verify cooldown ring appears near player and fills over 10 seconds
4. Verify ability can be used again after cooldown
5. On mobile (or device emulation), verify ability button appears bottom-right
6. Clear localStorage, play multiple games -- after 300s total time, dashBurst unlocks with announcement
  </verify>
  <done>Spacebar (desktop) and dedicated button (mobile) activate abilities. Cooldown ring indicator follows player. Decoy renders as translucent hologram. Phase Shift makes player translucent. Unlock notification shown at game over. Abilities count shown in stats. Mobile button shows ready/cooldown state.</done>
</task>

</tasks>

<verification>
- Clear localStorage completely, play from scratch
- Verify game starts with 0 abilities unlocked and no ability UI visible
- Play multiple games accumulating total time -- verify dashBurst unlocks at ~300s total
- Activate dashBurst with spacebar -- teleport + shockwave + brief invulnerability
- Verify cooldown ring near player shows progress
- Test decoy (set localStorage to unlock): holographic copy appears, homing projectiles redirect to it
- Test Phase Shift: projectiles pass through player, but standing in a danger zone still kills
- Test Time Warp: projectiles slow to 30%, player moves at 70%
- Verify abilities persist after page refresh (localStorage)
- Verify daily challenge seed unaffected by ability usage
- Test on mobile emulation: ability button visible when unlocked, tap activates
</verification>

<success_criteria>
- 4 unlockable abilities with distinct effects (teleport, decoy, phase shift, time slow)
- Milestone-based unlock system with cumulative tracking
- Abilities persist in localStorage (dodge-ai-abilities key)
- Cooldown-based activation via spacebar (desktop) and button (mobile)
- Visual cooldown indicator near player (small ring, minimal)
- Decoy hologram visually distinct from player
- Phase Shift: projectile immunity but hazard vulnerability
- Time Warp: affects both projectiles and player speed
- Unlock notification at game over
- Daily challenge determinism preserved
</success_criteria>

<output>
After completion, create `.planning/phases/05-new-mechanics/05-03-SUMMARY.md`
</output>
