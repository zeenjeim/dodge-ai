---
phase: 05-new-mechanics
plan: 02
type: execute
wave: 2
depends_on: [05-01]
files_modified: [index.html]
autonomous: true

must_haves:
  truths:
    - "Gravity wells appear and pull the player toward their center when active"
    - "Danger zones appear as red-outlined rectangles that damage the player if they stay inside too long"
    - "Arena shrink reduces playable area temporarily at high threat levels"
    - "All hazards show faded/outlined telegraphs before activating so deaths feel fair"
    - "AI triggers hazards based on detected player behavior patterns, not fixed timers"
    - "EMP (KABOOM) powerup destroys all active hazards; Ghost (NOPE) makes player immune to hazard damage"
    - "Maximum 2 hazards active simultaneously with 10s cooldown between spawns"
  artifacts:
    - path: "index.html"
      provides: "Hazard class and 3 hazard types integrated with AI brain"
      contains: "class Hazard"
  key_links:
    - from: "AIBrain.getHighestConfidencePattern"
      to: "Game.shouldSpawnHazard"
      via: "pattern confidence check triggers hazard spawn"
      pattern: "shouldSpawnHazard"
    - from: "Game.shouldSpawnHazard"
      to: "Hazard constructor"
      via: "pattern type determines hazard type and location"
      pattern: "new Hazard"
    - from: "Hazard.applyForce"
      to: "Game.update player position"
      via: "gravity well pull on player each frame"
      pattern: "applyForce.*player"
---

<objective>
Add 3 environmental hazard types (gravity well, danger zone, arena shrink) triggered by the AI brain based on detected player behavior patterns.

Purpose: Hazards force the player to adapt by reshaping the dodge space. The AI deploying hazards based on player patterns reinforces the core value ("the AI feels genuinely intelligent"). This directly fulfills MECH-02.

Output: index.html with Hazard class, 3 hazard types with telegraph/active/expire lifecycle, AI-triggered spawning, and powerup counterplay (EMP destroys, Ghost immunizes).
</objective>

<execution_context>
@C:\Users\Zahi\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\Zahi\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-new-mechanics/05-RESEARCH.md
@.planning/phases/05-new-mechanics/05-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Hazard class with telegraph/active/expire lifecycle and 3 hazard type implementations</name>
  <files>index.html</files>
  <action>
Add a Hazard class BEFORE the Game class (after the Boss class). The class handles 3 types with a shared lifecycle.

```javascript
class Hazard {
  constructor(x, y, type, opts = {}) {
    this.x = x;
    this.y = y;
    this.type = type; // 'gravity', 'danger-zone', 'shrink'
    this.radius = opts.radius || 80;        // gravity well radius
    this.strength = opts.strength || 120;    // gravity pull strength
    this.width = opts.width || 0;            // danger zone width
    this.height = opts.height || 0;          // danger zone height
    this.telegraphTime = opts.telegraph || 2.5; // seconds of preview
    this.activeTime = opts.duration || 10.0;
    this.age = 0;
    this.phase = 'telegraph';
    // Danger zone: player must leave within 1s after activation
    this.playerInsideTime = 0;
    // Arena shrink: how much border encroaches (pixels)
    this.shrinkAmount = opts.shrinkAmount || 60;
  }

  update(dt) {
    this.age += dt;
    if (this.age < this.telegraphTime) this.phase = 'telegraph';
    else if (this.age < this.telegraphTime + this.activeTime) this.phase = 'active';
    else this.phase = 'expired';
  }

  // Gravity well: pull player toward center
  applyGravityToPlayer(player, dt) {
    if (this.phase !== 'active' || this.type !== 'gravity') return;
    const dx = this.x - player.x;
    const dy = this.y - player.y;
    const dist = Math.sqrt(dx * dx + dy * dy);
    if (dist < this.radius && dist > 5) {
      const force = (this.strength / (dist * dist)) * this.radius * dt;
      // Adjust player target position (player uses lerp to targetX/targetY)
      // Return force vector for Game to apply
      return { fx: (dx / dist) * force, fy: (dy / dist) * force };
    }
    return null;
  }

  // Danger zone: check if player is inside
  isPlayerInside(px, py) {
    if (this.type !== 'danger-zone' || this.phase !== 'active') return false;
    return px > this.x - this.width / 2 && px < this.x + this.width / 2 &&
           py > this.y - this.height / 2 && py < this.y + this.height / 2;
  }

  // Arena shrink: get the reduced arena bounds
  getArenaBounds(fullW, fullH) {
    if (this.type !== 'shrink' || this.phase !== 'active') return null;
    const progress = Math.min(1, (this.age - this.telegraphTime) / 2); // 2s to fully shrink
    const s = this.shrinkAmount * progress;
    return { left: s, top: s, right: fullW - s, bottom: fullH - s };
  }

  draw(ctx, fullW, fullH) {
    if (this.phase === 'expired') return;
    const isTelegraph = this.phase === 'telegraph';

    if (this.type === 'gravity') {
      // Muted purple radial gradient - faded during telegraph, stronger when active
      const alpha = isTelegraph
        ? 0.12 + Math.sin(this.age * 4) * 0.04
        : 0.22 + Math.sin(this.age * 6) * 0.06;
      ctx.globalAlpha = alpha;
      ctx.strokeStyle = '#8b5cf6';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
      ctx.stroke();
      if (!isTelegraph) {
        const grad = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.radius);
        grad.addColorStop(0, 'rgba(139, 92, 246, 0.12)');
        grad.addColorStop(1, 'rgba(139, 92, 246, 0)');
        ctx.fillStyle = grad;
        ctx.fill();
      }
      ctx.globalAlpha = 1;
    }

    else if (this.type === 'danger-zone') {
      // Dark red rectangle - outlined during telegraph, filled when active
      const alpha = isTelegraph
        ? 0.1 + Math.sin(this.age * 3) * 0.04
        : 0.18 + Math.sin(this.age * 5) * 0.05;
      ctx.globalAlpha = alpha;
      ctx.strokeStyle = '#dc2626';
      ctx.lineWidth = 2;
      ctx.strokeRect(this.x - this.width / 2, this.y - this.height / 2, this.width, this.height);
      if (!isTelegraph) {
        ctx.fillStyle = 'rgba(220, 38, 38, 0.08)';
        ctx.fillRect(this.x - this.width / 2, this.y - this.height / 2, this.width, this.height);
      }
      ctx.globalAlpha = 1;
    }

    else if (this.type === 'shrink') {
      // Cyan border creeping inward
      const bounds = this.getArenaBounds(fullW, fullH);
      const alpha = isTelegraph
        ? 0.08 + Math.sin(this.age * 3) * 0.03
        : 0.2;
      ctx.globalAlpha = alpha;
      ctx.strokeStyle = '#22d3ee';
      ctx.lineWidth = 3;
      if (bounds) {
        ctx.strokeRect(bounds.left, bounds.top, bounds.right - bounds.left, bounds.bottom - bounds.top);
        // Fill the encroached border area with translucent cyan
        ctx.fillStyle = 'rgba(34, 211, 238, 0.04)';
        // Top strip
        ctx.fillRect(0, 0, fullW, bounds.top);
        // Bottom strip
        ctx.fillRect(0, bounds.bottom, fullW, fullH - bounds.bottom);
        // Left strip
        ctx.fillRect(0, bounds.top, bounds.left, bounds.bottom - bounds.top);
        // Right strip
        ctx.fillRect(bounds.right, bounds.top, fullW - bounds.right, bounds.bottom - bounds.top);
      } else {
        // Telegraph: show faint outline of where shrink will be
        const s = this.shrinkAmount;
        ctx.setLineDash([8, 4]);
        ctx.strokeRect(s, s, fullW - s * 2, fullH - s * 2);
        ctx.setLineDash([]);
      }
      ctx.globalAlpha = 1;
    }
  }

  isExpired() { return this.phase === 'expired'; }
}
```

IMPORTANT VISUAL DESIGN: Hazard colors must be MUTED (dark purples, deep reds at low opacity). Projectiles remain the primary visual threat. Hazards are background danger. Maximum alpha for any hazard element: 0.25. This avoids the "competing for attention" pitfall from research.
  </action>
  <verify>
The Hazard class exists in the source. Check by searching for "class Hazard" in the file. No runtime test yet -- the class needs to be integrated in Task 2.
  </verify>
  <done>Hazard class with 3 types (gravity, danger-zone, shrink), telegraph/active/expire lifecycle, muted visual design, and per-type game mechanics (gravity pull, inside-check, arena bounds).</done>
</task>

<task type="auto">
  <name>Task 2: Integrate hazards into Game class with AI-triggered spawning and powerup counterplay</name>
  <files>index.html</files>
  <action>
1. In Game constructor (around line ~2299-2344), add hazard state:
   ```javascript
   this.hazards = [];
   this.hazardCooldown = 0; // seconds until next hazard can spawn
   ```

2. In Game.reset() (around line ~2540-2560), reset hazards:
   ```javascript
   this.hazards = [];
   this.hazardCooldown = 0;
   ```

3. Add shouldSpawnHazard() method to Game class:
   ```javascript
   shouldSpawnHazard() {
     if (this.hazards.length >= 2) return false;      // Max 2 active
     if (this.gameTime < 20) return false;             // Not before Phase 2
     if (this.hazardCooldown > 0) return false;        // 10s cooldown between
     const pattern = this.brain.getHighestConfidencePattern(this.gameTime);
     if (!pattern || pattern.confidence < 0.6) return false;
     // Higher chance at higher threat levels
     return this.rng() < (this.threatLevel * 0.25);
   }
   ```

4. Add spawnHazard() method to Game class. Hazard type based on AI-detected pattern:
   ```javascript
   spawnHazard() {
     const pattern = this.brain.getHighestConfidencePattern(this.gameTime);
     if (!pattern) return;

     let hazard;
     if (pattern.type === 'safe-zone' && this.phase >= 1) {
       // Gravity well at player's favorite safe zone
       const zoneCenter = this.brain.safeZoneDetector.getZoneCenter(pattern.zone, this.w, this.h);
       hazard = new Hazard(zoneCenter.x, zoneCenter.y, 'gravity', {
         radius: 70 + this.rng() * 30, duration: 8 + this.rng() * 4
       });
     } else if (pattern.type === 'cornering' && this.phase >= 2) {
       // Danger zone at the corner the player camps
       const edgeTarget = this._getEdgeTarget(pattern.edge);
       const w = 120 + this.rng() * 60;
       const h = 120 + this.rng() * 60;
       hazard = new Hazard(edgeTarget.x, edgeTarget.y, 'danger-zone', {
         width: w, height: h, duration: 10 + this.rng() * 5
       });
     } else if (this.threatLevel > 0.65 && this.phase >= 3) {
       // Arena shrink when player is doing too well at high phases
       hazard = new Hazard(0, 0, 'shrink', {
         shrinkAmount: 40 + this.rng() * 30, duration: 12 + this.rng() * 4
       });
     } else {
       return; // No valid hazard for this pattern
     }

     this.hazards.push(hazard);
     this.hazardCooldown = 10; // 10 second cooldown
   }
   ```
   All randomness uses this.rng() for daily challenge determinism.

5. In Game.update() (around line ~2727 where updateThreatLevel is called), add hazard update logic:
   ```javascript
   // Update hazards
   this.hazardCooldown = Math.max(0, this.hazardCooldown - dt);
   if (this.shouldSpawnHazard()) this.spawnHazard();
   for (let i = this.hazards.length - 1; i >= 0; i--) {
     const h = this.hazards[i];
     h.update(dt);
     if (h.isExpired()) { this.hazards.splice(i, 1); continue; }

     // Gravity well: pull player
     if (h.type === 'gravity') {
       const force = h.applyGravityToPlayer(this.player, dt);
       if (force && !this.effects.ghost.active) {
         this.player.x += force.fx;
         this.player.y += force.fy;
       }
     }

     // Danger zone: damage if player stays inside >1s
     if (h.type === 'danger-zone') {
       if (h.isPlayerInside(this.player.x, this.player.y)) {
         if (!this.effects.ghost.active) {
           h.playerInsideTime += dt;
           if (h.playerInsideTime > 1.0) {
             // Kill player -- use existing die() method
             this.deathContext = { killerType: 'danger-zone', killerColor: '#dc2626' };
             this.die();
             return;
           }
         }
       } else {
         h.playerInsideTime = 0; // Reset timer when player leaves
       }
     }

     // Arena shrink: constrain player position
     if (h.type === 'shrink') {
       const bounds = h.getArenaBounds(this.w, this.h);
       if (bounds && !this.effects.ghost.active) {
         this.player.x = Math.max(bounds.left + 10, Math.min(bounds.right - 10, this.player.x));
         this.player.y = Math.max(bounds.top + 10, Math.min(bounds.bottom - 10, this.player.y));
       }
     }
   }
   ```

6. In Game.render() (around line ~3400-3410, BEFORE projectile drawing), draw hazards:
   ```javascript
   // Draw hazards (background layer -- before projectiles)
   for (const h of this.hazards) h.draw(ctx, this.w, this.h);
   ```
   Also add hazard drawing in the game-over render method if hazards are visible during death freeze.

7. Powerup counterplay -- in the EMP activation handler (search for 'emp' powerup effect, where projectiles are cleared):
   - Add: `this.hazards = [];` to destroy all hazards when EMP activates.
   - The Ghost (ghost effect) immunity is already handled by the `!this.effects.ghost.active` checks above.

8. Gravity well should also affect nearby projectiles (pull them toward center) to create additional chaos. In the projectile update loop, for each active gravity hazard, apply a small pull on projectiles within radius:
   ```javascript
   for (const h of this.hazards) {
     if (h.type === 'gravity' && h.phase === 'active') {
       for (const p of this.projectiles) {
         const dx = h.x - p.x;
         const dy = h.y - p.y;
         const dist = Math.sqrt(dx * dx + dy * dy);
         if (dist < h.radius && dist > 5) {
           const force = (h.strength * 0.5 / (dist * dist)) * h.radius * dt;
           p.vx += (dx / dist) * force;
           p.vy += (dy / dist) * force;
         }
       }
     }
   }
   ```
   Place this in Game.update() alongside the hazard loop, NOT inside Projectile.update().
  </action>
  <verify>
Open index.html in browser. Play to Phase 2+ (~20s). Wait for AI to detect patterns:
1. If camping a zone: gravity well appears (purple) with telegraph then pull
2. If camping edges: danger zone appears (red rectangle)
3. At high threat in Phase 4+: arena shrink (cyan border) restricts space
4. Pick up EMP powerup: all hazards disappear
5. Pick up Ghost: hazards visually present but player is immune
6. Console check: `_game.hazards.length` should be 0-2 at any time
  </verify>
  <done>3 hazard types integrated with AI-triggered spawning (pattern-based), telegraph/active/expire lifecycle visible in-game, max 2 active with 10s cooldown, EMP destroys all hazards, Ghost grants immunity. Hazard visuals are muted background elements, not competing with projectiles for attention.</done>
</task>

</tasks>

<verification>
- Play full game from start to Phase 5+ (HUNTING)
- Verify hazards appear after ~20s when AI has detected player patterns
- Verify gravity wells pull player (and nearby projectiles) toward center
- Verify danger zones kill player if they stay inside for >1 second
- Verify arena shrink constrains player movement to reduced bounds
- Verify telegraph phase (2.5s faded preview) precedes all hazard activations
- Verify max 2 hazards active at any time
- Verify EMP powerup clears all hazards
- Verify Ghost powerup makes player immune to hazard effects
- Verify daily challenge determinism (hazard spawns use this.rng())
</verification>

<success_criteria>
- 3 environmental hazard types dynamically change the dodge space
- AI triggers hazards based on detected player behavior (safe-zone -> gravity well, cornering -> danger zone, high threat -> arena shrink)
- All hazards telegraph before activating (faded/outlined preview)
- Powerup counterplay: EMP destroys hazards, Ghost immunizes
- Max 2 hazards active, 10s cooldown between spawns
- Hazard visuals are muted (low opacity) so projectiles remain the primary visual threat
- Deaths to hazards feel fair due to telegraphing
</success_criteria>

<output>
After completion, create `.planning/phases/05-new-mechanics/05-02-SUMMARY.md`
</output>
