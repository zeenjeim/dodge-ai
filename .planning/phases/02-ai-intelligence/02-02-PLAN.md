---
phase: 02-ai-intelligence
plan: 02
type: execute
wave: 2
depends_on: [02-01]
files_modified: [index.html]
autonomous: true

must_haves:
  truths:
    - "AI detects micro-habits: panic reversals, cornering tendency, speed changes under pressure"
    - "AI tracks preferred safe zones with recency weighting and exploits them with targeted spawns"
    - "AI remembers dodge sequences and fires counter-pattern projectiles aimed where the player tends to go"
    - "Counter-pattern projectiles have a subtle purple tint distinguishing them from regular shots"
    - "When the AI fires a counter-pattern shot, a callout message explains what it detected"
    - "Pattern data uses stack-with-decay: recent samples weighted 3x heavier than older ones"
  artifacts:
    - path: "index.html"
      provides: "4 detector modules, counter-pattern firing logic, pattern-triggered callout messages"
      contains: "PanicDetector"
  key_links:
    - from: "brain.trackPosition()"
      to: "all 4 detectors"
      via: "detector.update() called from trackPosition"
      pattern: "this\\.detectors.*update|detector.*update"
    - from: "spawnProjectileFromWarning()"
      to: "brain.getHighestConfidencePattern()"
      via: "counter-pattern targeting branch"
      pattern: "counterPattern|getHighestConfidencePattern"
    - from: "counter-pattern firing"
      to: "showLearningMessage()"
      via: "callout when counter-pattern shot fires"
      pattern: "showLearningMessage.*counter"
    - from: "brain.save()"
      to: "detector serialize"
      via: "detector states included in save data"
      pattern: "panicProfile|dodgeSequences"
---

<objective>
Add 4 pattern detector modules to AIBrain and integrate counter-pattern firing into the projectile spawn system, with explicit callouts when the AI acts on detected patterns.

Purpose: AI-02, AI-03, AI-04 require the AI to detect micro-habits, track safe zones, and remember dodge sequences. The locked decisions demand that counter-attacks use explicit callouts so the player knows they've been read. This plan adds the detection and counter-attack intelligence that makes the AI feel genuinely smart. Plan 02-01's callout system provides the visibility layer; this plan feeds it with real pattern detections.

Output: Modified index.html with DirectionBiasDetector (enhanced), SafeZoneDetector, DodgeSequenceDetector, PanicDetector integrated into AIBrain, counter-pattern firing in spawnProjectileFromWarning(), and pattern-triggered learning messages.
</objective>

<execution_context>
@C:\Users\Zahi\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\Zahi\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@C:\Users\Zahi\claudecode\dodge-ai\.planning\PROJECT.md
@C:\Users\Zahi\claudecode\dodge-ai\.planning\ROADMAP.md
@C:\Users\Zahi\claudecode\dodge-ai\.planning\STATE.md
@C:\Users\Zahi\claudecode\dodge-ai\.planning\phases\02-ai-intelligence\02-RESEARCH.md
@C:\Users\Zahi\claudecode\dodge-ai\.planning\phases\02-ai-intelligence\02-01-SUMMARY.md
@C:\Users\Zahi\claudecode\dodge-ai\index.html
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add 4 detector modules and integrate into AIBrain</name>
  <files>index.html</files>
  <action>
Add 4 detector classes before the AIBrain class (before line 812). Each detector follows the same interface: `update(px, py, vx, vy, gameTime, w, h)`, `getActivePattern()`, `serialize()`, `deserialize(data)`.

**All detectors use stack-with-decay weighting** (per discretion decision): recent samples (last 10s) count 3x more than older samples (30s+). Implement this as a helper function `decayWeight(sampleTime, currentTime)`:
```javascript
function decayWeight(sampleTime, currentTime) {
  const age = currentTime - sampleTime;
  if (age < 10) return 3.0;
  if (age < 20) return 2.0;
  if (age < 30) return 1.0;
  return 0.5;
}
```

Place `decayWeight` as a standalone utility near `getDirectionName()` at the top of the script block.

**Detector 1: DirectionBiasDetector** (enhances existing directionBias data)

This detector wraps the existing `directionBias` tracking with recency-weighted analysis and clockwise/counterclockwise detection.

```javascript
class DirectionBiasDetector {
  constructor() {
    this.samples = []; // { direction: 'left'|'right'|'up'|'down', time: number }
    this.maxSamples = 100;
    this._lastCalloutDirection = null;
  }

  update(dx, dy, gameTime) {
    // dx, dy are movement deltas (already available from trackPosition)
    const dist = Math.sqrt(dx * dx + dy * dy);
    if (dist < 3) return;
    const angle = Math.atan2(dy, dx);
    let direction;
    if (angle > -0.785 && angle <= 0.785) direction = 'right';
    else if (angle > 0.785 && angle <= 2.356) direction = 'down';
    else if (angle > -2.356 && angle <= -0.785) direction = 'up';
    else direction = 'left';
    this.samples.push({ direction, angle, time: gameTime });
    if (this.samples.length > this.maxSamples) this.samples.shift();
  }

  getActivePattern(gameTime) {
    if (this.samples.length < 15) return null;
    // Recency-weighted direction counts
    const counts = { left: 0, right: 0, up: 0, down: 0 };
    let totalWeight = 0;
    for (const s of this.samples) {
      const w = decayWeight(s.time, gameTime);
      counts[s.direction] += w;
      totalWeight += w;
    }
    const entries = Object.entries(counts).sort((a, b) => b[1] - a[1]);
    const dominantPct = (entries[0][1] / totalWeight) * 100;
    if (dominantPct < 32) return null;

    // Detect clockwise/counterclockwise tendency from consecutive angle changes
    let cwCount = 0, ccwCount = 0;
    const recent = this.samples.slice(-30);
    for (let i = 1; i < recent.length; i++) {
      let diff = recent[i].angle - recent[i - 1].angle;
      // Normalize to [-PI, PI]
      while (diff > Math.PI) diff -= 2 * Math.PI;
      while (diff < -Math.PI) diff += 2 * Math.PI;
      if (diff > 0.1) cwCount++;
      else if (diff < -0.1) ccwCount++;
    }
    const rotationBias = cwCount > ccwCount * 1.5 ? 'clockwise' : ccwCount > cwCount * 1.5 ? 'counterclockwise' : null;

    return {
      type: 'direction-bias',
      direction: entries[0][0],
      pct: Math.round(dominantPct),
      rotation: rotationBias,
      confidence: Math.min(1, this.samples.length / 60),
    };
  }

  serialize() {
    // Only keep summary for cross-session
    const pattern = this.getActivePattern(this.samples.length > 0 ? this.samples[this.samples.length - 1].time : 0);
    return pattern ? { direction: pattern.direction, rotation: pattern.rotation } : null;
  }
  deserialize(data) { /* Cross-session data seeded via brain profile, not full sample restore */ }
}
```

**Detector 2: SafeZoneDetector** (enhances existing zoneVisits)

```javascript
class SafeZoneDetector {
  constructor() {
    this.visits = []; // { zone: 0-8, time: number }
    this.maxVisits = 200;
    this.zoneNames = ['top-left', 'top-center', 'top-right', 'mid-left', 'center', 'mid-right', 'bottom-left', 'bottom-center', 'bottom-right'];
  }

  update(px, py, gameTime, w, h) {
    const zx = Math.min(2, Math.floor((px / w) * 3));
    const zy = Math.min(2, Math.floor((py / h) * 3));
    const zone = zy * 3 + zx;
    this.visits.push({ zone, time: gameTime });
    if (this.visits.length > this.maxVisits) this.visits.shift();
  }

  getActivePattern(gameTime) {
    if (this.visits.length < 20) return null;
    // Recency-weighted zone counts
    const counts = new Array(9).fill(0);
    let totalWeight = 0;
    for (const v of this.visits) {
      const w = decayWeight(v.time, gameTime);
      counts[v.zone] += w;
      totalWeight += w;
    }
    let maxIdx = 0;
    for (let i = 1; i < 9; i++) if (counts[i] > counts[maxIdx]) maxIdx = i;
    const dominantPct = (counts[maxIdx] / totalWeight) * 100;
    if (dominantPct < 20) return null; // Need at least 20% preference

    return {
      type: 'safe-zone',
      zone: maxIdx,
      zoneName: this.zoneNames[maxIdx],
      pct: Math.round(dominantPct),
      confidence: Math.min(1, this.visits.length / 100),
    };
  }

  getZoneCenter(zone, w, h) {
    const zx = zone % 3;
    const zy = Math.floor(zone / 3);
    return { x: (zx + 0.5) * (w / 3), y: (zy + 0.5) * (h / 3) };
  }

  serialize() {
    const pattern = this.getActivePattern(this.visits.length > 0 ? this.visits[this.visits.length - 1].time : 0);
    return pattern ? { zone: pattern.zone, zoneName: pattern.zoneName } : null;
  }
  deserialize(data) {}
}
```

**Detector 3: DodgeSequenceDetector**

```javascript
class DodgeSequenceDetector {
  constructor() {
    this.sequences = []; // { dirs: string (e.g. 'RLUD'), time: number }
    this.currentSeq = '';
    this.seqStartTime = 0;
    this.maxSeqs = 30;
    this.lastDirTime = 0;
  }

  update(dx, dy, gameTime) {
    const dist = Math.sqrt(dx * dx + dy * dy);
    if (dist < 3) return;
    const angle = Math.atan2(dy, dx);
    let dir;
    if (angle > -0.785 && angle <= 0.785) dir = 'R';
    else if (angle > 0.785 && angle <= 2.356) dir = 'D';
    else if (angle > -2.356 && angle <= -0.785) dir = 'U';
    else dir = 'L';

    // If too long since last direction, start new sequence
    if (gameTime - this.lastDirTime > 1.5 || this.currentSeq.length >= 6) {
      if (this.currentSeq.length >= 3) {
        this.sequences.push({ dirs: this.currentSeq, time: gameTime });
        if (this.sequences.length > this.maxSeqs) this.sequences.shift();
      }
      this.currentSeq = '';
      this.seqStartTime = gameTime;
    }

    // Only add if different from last direction in sequence
    if (this.currentSeq.length === 0 || this.currentSeq[this.currentSeq.length - 1] !== dir) {
      this.currentSeq += dir;
    }
    this.lastDirTime = gameTime;
  }

  getActivePattern(gameTime) {
    if (this.sequences.length < 5) return null;

    // Find repeated sequences (same 3+ char pattern appears 3+ times)
    const freqMap = {};
    for (const seq of this.sequences) {
      // Check all 3-length substrings
      for (let i = 0; i <= seq.dirs.length - 3; i++) {
        const sub = seq.dirs.substring(i, i + 3);
        freqMap[sub] = (freqMap[sub] || 0) + decayWeight(seq.time, gameTime);
      }
    }

    let bestSeq = null, bestScore = 0;
    for (const [seq, score] of Object.entries(freqMap)) {
      if (score > bestScore) { bestScore = score; bestSeq = seq; }
    }

    if (!bestSeq || bestScore < 4) return null; // Need meaningful repetition

    const dirNames = { R: 'right', L: 'left', U: 'up', D: 'down' };
    const readable = bestSeq.split('').map(d => dirNames[d]).join('-');

    return {
      type: 'dodge-sequence',
      sequence: bestSeq,
      readable: readable,
      score: Math.round(bestScore),
      confidence: Math.min(1, bestScore / 10),
    };
  }

  // Predict next direction given current partial sequence
  predictNext(currentDir) {
    const pattern = this.getActivePattern(this.lastDirTime);
    if (!pattern) return null;
    const seq = pattern.sequence;
    const idx = seq.indexOf(currentDir);
    if (idx >= 0 && idx < seq.length - 1) {
      const nextDir = seq[idx + 1];
      return nextDir; // R, L, U, D
    }
    return null;
  }

  serialize() {
    const pattern = this.getActivePattern(this.lastDirTime);
    return pattern ? { sequence: pattern.sequence } : null;
  }
  deserialize(data) {}
}
```

**Detector 4: PanicDetector**

```javascript
class PanicDetector {
  constructor() {
    this.speedSamples = []; // { speed: number, time: number }
    this.reversals = []; // { time: number, x: number, y: number, angle: number }
    this.edgeEvents = []; // { time: number, edge: string }
    this.prevVx = 0;
    this.prevVy = 0;
    this.maxSamples = 100;
  }

  update(px, py, vx, vy, gameTime, w, h) {
    const speed = Math.sqrt(vx * vx + vy * vy);
    this.speedSamples.push({ speed, time: gameTime });
    if (this.speedSamples.length > this.maxSamples) this.speedSamples.shift();

    // Detect direction reversal (dot product of consecutive velocities)
    if (this.prevVx !== 0 || this.prevVy !== 0) {
      const prevSpeed = Math.sqrt(this.prevVx * this.prevVx + this.prevVy * this.prevVy);
      if (speed > 2 && prevSpeed > 2) {
        const dot = vx * this.prevVx + vy * this.prevVy;
        const normalized = dot / (speed * prevSpeed);
        if (normalized < -0.3) {
          this.reversals.push({ time: gameTime, x: px, y: py, angle: Math.atan2(vy, vx) });
          if (this.reversals.length > 30) this.reversals.shift();
        }
      }
    }
    this.prevVx = vx;
    this.prevVy = vy;

    // Detect edge/corner hugging
    const margin = 40;
    const edges = [];
    if (px < margin) edges.push('left');
    if (px > w - margin) edges.push('right');
    if (py < margin) edges.push('top');
    if (py > h - margin) edges.push('bottom');
    if (edges.length > 0) {
      this.edgeEvents.push({ time: gameTime, edge: edges.join('-') });
      if (this.edgeEvents.length > 50) this.edgeEvents.shift();
    }
  }

  getActivePattern(gameTime) {
    // Check for panic reversals (5+ in last 15 seconds)
    const recentReversals = this.reversals.filter(r => gameTime - r.time < 15);
    if (recentReversals.length >= 5) {
      const avgAngle = Math.atan2(
        recentReversals.reduce((s, r) => s + Math.sin(r.angle), 0) / recentReversals.length,
        recentReversals.reduce((s, r) => s + Math.cos(r.angle), 0) / recentReversals.length
      );
      return {
        type: 'panic-reversal',
        frequency: recentReversals.length,
        dominantAngle: avgAngle,
        confidence: Math.min(1, recentReversals.length / 10),
        description: 'Panic reversal detected',
      };
    }

    // Check for cornering tendency (10+ edge events in last 20 seconds)
    const recentEdges = this.edgeEvents.filter(e => gameTime - e.time < 20);
    if (recentEdges.length >= 10) {
      // Find most common edge/corner
      const edgeCounts = {};
      for (const e of recentEdges) {
        edgeCounts[e.edge] = (edgeCounts[e.edge] || 0) + 1;
      }
      const topEdge = Object.entries(edgeCounts).sort((a, b) => b[1] - a[1])[0];
      return {
        type: 'cornering',
        edge: topEdge[0],
        frequency: topEdge[1],
        confidence: Math.min(1, topEdge[1] / 15),
        description: `Cornering tendency: ${topEdge[0]}`,
      };
    }

    // Check for speed drops under pressure (average speed dropped 40%+ in last 10s vs previous 10s)
    if (this.speedSamples.length > 30) {
      const recent = this.speedSamples.filter(s => gameTime - s.time < 10);
      const older = this.speedSamples.filter(s => gameTime - s.time >= 10 && gameTime - s.time < 20);
      if (recent.length > 5 && older.length > 5) {
        const recentAvg = recent.reduce((s, r) => s + r.speed, 0) / recent.length;
        const olderAvg = older.reduce((s, r) => s + r.speed, 0) / older.length;
        if (olderAvg > 1 && recentAvg < olderAvg * 0.6) {
          return {
            type: 'speed-freeze',
            recentSpeed: recentAvg,
            previousSpeed: olderAvg,
            confidence: 0.7,
            description: 'Speed drop under pressure',
          };
        }
      }
    }

    return null;
  }

  serialize() {
    return {
      avgReversalFreq: this.reversals.length,
      cornerPreference: this.edgeEvents.length > 0 ? this.edgeEvents[this.edgeEvents.length - 1].edge : null,
    };
  }
  deserialize(data) {}
}
```

**Integrate detectors into AIBrain:**

In the AIBrain constructor (line 813), after existing initializations, add:
```javascript
this.directionDetector = new DirectionBiasDetector();
this.safeZoneDetector = new SafeZoneDetector();
this.dodgeSequenceDetector = new DodgeSequenceDetector();
this.panicDetector = new PanicDetector();
```

In `trackPosition()` (line 833), after existing logic but before `this.lastPlayerPos = { x, y }` (line 862), add detector updates:
```javascript
// Feed detectors
const dx = this.lastPlayerPos ? x - this.lastPlayerPos.x : 0;
const dy = this.lastPlayerPos ? y - this.lastPlayerPos.y : 0;
const vx = dx; // per-frame velocity (already computed above, reuse)
const vy = dy;
this.directionDetector.update(dx, dy, time / 1000);
this.safeZoneDetector.update(x, y, time / 1000, w, h);
this.dodgeSequenceDetector.update(dx, dy, time / 1000);
this.panicDetector.update(x, y, vx, vy, time / 1000, w, h);
```

IMPORTANT: Note that `trackPosition` receives `time` in milliseconds (called as `this.gameTime * 1000`), but detectors use seconds. Divide by 1000 when passing to detectors.

Also note that `dx` and `dy` are already computed in the existing trackPosition logic (lines 841-842). Reuse those values rather than recomputing. The detector update calls should go inside the `if (this.lastPlayerPos)` block, after the existing dodge direction tracking but before `this.lastPlayerPos = { x, y }`.

Add `getHighestConfidencePattern(gameTime)` method to AIBrain:
```javascript
getHighestConfidencePattern(gameTime) {
  const patterns = [
    this.directionDetector.getActivePattern(gameTime),
    this.safeZoneDetector.getActivePattern(gameTime),
    this.dodgeSequenceDetector.getActivePattern(gameTime),
    this.panicDetector.getActivePattern(gameTime),
  ].filter(Boolean);
  if (patterns.length === 0) return null;
  patterns.sort((a, b) => b.confidence - a.confidence);
  return patterns[0];
}

getActivePatternCount(gameTime) {
  return [
    this.directionDetector.getActivePattern(gameTime),
    this.safeZoneDetector.getActivePattern(gameTime),
    this.dodgeSequenceDetector.getActivePattern(gameTime),
    this.panicDetector.getActivePattern(gameTime),
  ].filter(Boolean).length;
}
```

In `brain.reset()` (line 826), add detector resets (clear per-run data but NOT cross-session):
```javascript
this.directionDetector = new DirectionBiasDetector();
this.safeZoneDetector = new SafeZoneDetector();
this.dodgeSequenceDetector = new DodgeSequenceDetector();
this.panicDetector = new PanicDetector();
```

Update `getInsight()` (line 924) to include detector-based messages in the rotation. Add entries for detected patterns to the `msgs` array:
```javascript
const dirPattern = this.directionDetector.getActivePattern(Date.now() / 1000);
if (dirPattern && dirPattern.rotation) msgs.push(`${dirPattern.rotation === 'clockwise' ? 'Clockwise' : 'Counterclockwise'} dodger. Predictable.`);
const safePattern = this.safeZoneDetector.getActivePattern(Date.now() / 1000);
if (safePattern) msgs.push(`Your ${safePattern.zoneName} obsession is noted.`);
const panicPattern = this.panicDetector.getActivePattern(Date.now() / 1000);
if (panicPattern && panicPattern.type === 'panic-reversal') msgs.push(`Panic reversals detected. Delicious.`);
if (panicPattern && panicPattern.type === 'cornering') msgs.push(`Hugging the ${panicPattern.edge}? Bold choice.`);
```

Expand `save()` to include detector serialization (add these fields to the JSON alongside existing data):
```javascript
panicProfile: this.panicDetector.serialize(),
dodgeSequenceSummary: this.dodgeSequenceDetector.serialize(),
safeZoneSummary: this.safeZoneDetector.serialize(),
directionSummary: this.directionDetector.serialize(),
```
  </action>
  <verify>
1. Search for `class DirectionBiasDetector` -- should exist
2. Search for `class SafeZoneDetector` -- should exist
3. Search for `class DodgeSequenceDetector` -- should exist
4. Search for `class PanicDetector` -- should exist
5. Search for `getHighestConfidencePattern` -- should be a method on AIBrain
6. Search for `getActivePatternCount` -- should be a method on AIBrain
7. Search for `directionDetector.update` -- should be called from trackPosition
8. Open in browser, play for 20+ seconds moving in one direction. Check brain panel insight text -- should show detector-based messages about your pattern
  </verify>
  <done>4 detector classes implemented with stack-with-decay weighting. All detectors update every frame from trackPosition(). AIBrain exposes getHighestConfidencePattern() and getActivePatternCount(). Detector summaries included in save data. Brain insight messages enriched with detector output.</done>
</task>

<task type="auto">
  <name>Task 2: Add counter-pattern firing and pattern-triggered callouts</name>
  <files>index.html</files>
  <action>
**Part A: Counter-pattern firing in spawnProjectileFromWarning()**

In `spawnProjectileFromWarning()` (line 2413), AFTER the existing aim logic (after line 2458 where the final `else` block ends) but BEFORE the projectile type determination (line 2466), add a counter-pattern override. This does NOT replace existing aim logic -- it adds an additional targeting path that fires when the AI has high-confidence patterns.

The counter-pattern chance is controlled by a property `this.counterPatternChance` which starts at 0 and is set by the adaptive difficulty system in Plan 02-03. For now, base it on brain confidence: `this.brain.getConfidence() / 100 * 0.4` (maxing at ~40% chance at full confidence).

```javascript
// Counter-pattern targeting (AI fires based on detected patterns)
const counterChance = this.brain.getConfidence() / 100 * 0.4;
if (Math.random() < counterChance) {
  const gameTimeSec = this.gameTime;
  const pattern = this.brain.getHighestConfidencePattern(gameTimeSec);
  if (pattern) {
    let counterFired = false;
    switch (pattern.type) {
      case 'safe-zone': {
        const zoneCenter = this.brain.safeZoneDetector.getZoneCenter(pattern.zone, this.w, this.h);
        targetX = zoneCenter.x + (Math.random() - 0.5) * 50;
        targetY = zoneCenter.y + (Math.random() - 0.5) * 50;
        this.showLearningMessage('counter', `Targeting your ${pattern.zoneName} safe zone.`);
        counterFired = true;
        break;
      }
      case 'direction-bias': {
        if (pattern.rotation) {
          this.showLearningMessage('counter', `${pattern.rotation === 'clockwise' ? 'Clockwise' : 'Counter-clockwise'}? Really? I had you in seconds.`);
        } else {
          this.showLearningMessage('counter', `You dodge ${pattern.direction} ${pattern.pct}% of the time. Aiming there.`);
        }
        // Aim at where they tend to dodge TO
        const predicted = this.brain.getPredictedDodgeTarget(px, py, this.w, this.h);
        if (predicted) { targetX = predicted.x; targetY = predicted.y; }
        counterFired = true;
        break;
      }
      case 'panic-reversal': {
        // Fire from the direction they reverse toward (catching mid-reversal)
        targetX = px + Math.cos(pattern.dominantAngle) * 100;
        targetY = py + Math.sin(pattern.dominantAngle) * 100;
        this.showLearningMessage('counter', `Exploiting your panic reflex.`);
        counterFired = true;
        break;
      }
      case 'cornering': {
        // Fire at their preferred corner/edge
        const edgeTarget = this._getEdgeTarget(pattern.edge);
        if (edgeTarget) { targetX = edgeTarget.x; targetY = edgeTarget.y; }
        this.showLearningMessage('counter', `Hugging the ${pattern.edge}? Here's a welcome gift.`);
        counterFired = true;
        break;
      }
      case 'dodge-sequence': {
        // Predict next dodge direction from sequence and aim there
        const nextDir = this.brain.dodgeSequenceDetector.predictNext(
          this.player.vx > 1 ? 'R' : this.player.vx < -1 ? 'L' : this.player.vy > 1 ? 'D' : 'U'
        );
        if (nextDir) {
          const offsets = { R: [80, 0], L: [-80, 0], U: [0, -80], D: [0, 80] };
          const off = offsets[nextDir];
          targetX = px + off[0] + (Math.random() - 0.5) * 30;
          targetY = py + off[1] + (Math.random() - 0.5) * 30;
          this.showLearningMessage('counter', `Let's see if you do ${pattern.readable} again.`);
          counterFired = true;
        }
        break;
      }
      case 'speed-freeze': {
        // Direct shot -- they're slowing down, so aim right at them
        targetX = px;
        targetY = py;
        this.showLearningMessage('counter', `Speed drop detected. Easy target.`);
        counterFired = true;
        break;
      }
    }

    // Mark this projectile as a counter-pattern shot for visual distinction
    if (counterFired) {
      this._lastShotWasCounter = true;
    }
  }
}
```

Add a helper method `_getEdgeTarget(edge)` to the Game class:
```javascript
_getEdgeTarget(edge) {
  const parts = edge.split('-');
  let x = this.w / 2, y = this.h / 2;
  for (const part of parts) {
    if (part === 'left') x = this.w * 0.15;
    if (part === 'right') x = this.w * 0.85;
    if (part === 'top') y = this.h * 0.15;
    if (part === 'bottom') y = this.h * 0.85;
  }
  return { x, y };
}
```

**Part B: Visual distinction for counter-pattern projectiles**

After the projectile is created (line 2486, `this.projectiles.push(proj)`), add a flag check:
```javascript
if (this._lastShotWasCounter) {
  proj.isCounter = true;
  this._lastShotWasCounter = false;
}
```

In the Projectile `draw()` method, if `this.isCounter` is true, apply a subtle purple tint. Find the Projectile.draw method and add at the start of the draw function, before the main shape draw:
```javascript
if (this.isCounter) {
  // Subtle purple glow for counter-pattern shots
  ctx.shadowColor = '#8b5cf6';
  ctx.shadowBlur = 8;
}
```
And after the draw, reset: `ctx.shadowBlur = 0;`

Initialize `this._lastShotWasCounter = false` in Game's `start()` method.

**Part C: Detection callouts during gameplay (non-counter)**

In the `update()` method (line 1870), after `brain.trackPosition()` (line 1908), add a pattern-check callout that fires when a NEW pattern is first detected. This runs every ~60 frames (roughly once per second) to avoid performance overhead:

```javascript
// Pattern detection callouts (check every ~60 frames)
this._patternCheckCounter = (this._patternCheckCounter || 0) + 1;
if (this._patternCheckCounter >= 60) {
  this._patternCheckCounter = 0;
  this._detectedPatterns = this._detectedPatterns || {};
  const gameTimeSec = this.gameTime;
  const patterns = [
    this.brain.directionDetector.getActivePattern(gameTimeSec),
    this.brain.safeZoneDetector.getActivePattern(gameTimeSec),
    this.brain.dodgeSequenceDetector.getActivePattern(gameTimeSec),
    this.brain.panicDetector.getActivePattern(gameTimeSec),
  ].filter(Boolean);

  for (const p of patterns) {
    const key = p.type;
    if (!this._detectedPatterns[key] && p.confidence > 0.5) {
      this._detectedPatterns[key] = true;
      // First detection callout
      const messages = {
        'direction-bias': p.rotation
          ? `${p.rotation === 'clockwise' ? 'Clockwise' : 'Counter-clockwise'}? Really? Noted.`
          : `You dodge ${p.direction} ${p.pct}% of the time. Adorable.`,
        'safe-zone': `You love that ${p.zoneName}. Filing that away.`,
        'dodge-sequence': `${p.readable} â€” I see a pattern forming.`,
        'panic-reversal': `Panic reversals detected. That's basically a homing beacon.`,
        'cornering': `Edge hugger detected. The ${p.edge} isn't going to save you.`,
        'speed-freeze': `Speed drop when pressured. Exploitable.`,
      };
      if (messages[key]) this.showLearningMessage('detect', messages[key]);
      break; // Only one callout per check
    }
  }

  // Taunt if patterns persist (every 30-40 seconds after first detection)
  this._tauntTimer = (this._tauntTimer || 0) + 1;
  if (this._tauntTimer >= 30 && Object.keys(this._detectedPatterns).length >= 2) {
    this._tauntTimer = 0;
    const taunts = [
      'Still doing the same thing? Bold strategy.',
      'I already told you I see that. You just don\'t care, do you?',
      'At this point I\'m predicting your predictions.',
      'You\'re making this too easy. Change it up. Or don\'t. I\'m entertained either way.',
    ];
    this.showLearningMessage('taunt', taunts[Math.floor(Math.random() * taunts.length)]);
  }
}
```

Initialize in `start()`:
```javascript
this._patternCheckCounter = 0;
this._detectedPatterns = {};
this._tauntTimer = 0;
this._lastShotWasCounter = false;
```
  </action>
  <verify>
1. Search for `counterPatternChance\|counterChance\|_lastShotWasCounter` -- should appear in spawnProjectileFromWarning and start()
2. Search for `isCounter` -- should appear in projectile creation and draw
3. Search for `_patternCheckCounter` -- should appear in update() and start()
4. Search for `_getEdgeTarget` -- should be a method on Game
5. Open in browser, play for 30+ seconds dodging consistently in one direction. After ~15-20s, a detection callout should appear ("You dodge right 45% of the time. Adorable."). After ~25-30s, some projectiles should have purple glow (counter-pattern shots) and a counter callout should fire
6. No console errors during gameplay
  </verify>
  <done>Counter-pattern firing integrated into spawnProjectileFromWarning() with per-pattern targeting logic. Counter-pattern projectiles have purple glow visual distinction. Detection callouts fire when patterns first reach confidence threshold. Periodic taunts fire when 2+ patterns persist. All message types use the priority/cooldown system from Plan 02-01.</done>
</task>

</tasks>

<verification>
1. Fresh game: no pattern callouts in first 10-15 seconds (AI still collecting data)
2. Dodge consistently rightward for 20+ seconds: "You dodge right NN% of the time. Adorable." callout appears
3. Continue dodging right: eventually see counter-pattern projectiles (purple glow) aimed at your right dodge zone, with "Aiming there" counter callout
4. Hug a corner: cornering detection callout fires, followed by counter shots aimed at that corner
5. Make rapid direction reversals: panic reversal detection fires
6. After 2+ patterns detected, periodic taunt messages appear
7. Brain panel insight text includes detector-based messages (clockwise dodger, zone obsession, etc.)
8. Messages never overlap -- max 1 visible at a time with 8-12s cooldown
9. No console errors, no performance degradation (detectors update within frame budget)
</verification>

<success_criteria>
- 4 detector classes implemented: DirectionBiasDetector, SafeZoneDetector, DodgeSequenceDetector, PanicDetector
- All detectors update from trackPosition() every frame
- Counter-pattern firing in spawnProjectileFromWarning() with per-pattern targeting
- Counter-pattern projectiles visually distinct (purple glow)
- Detection callouts fire on first pattern detection (confidence > 0.5)
- Counter-attack callouts fire when AI shoots based on patterns
- Periodic taunts fire when patterns persist
- Stack-with-decay weighting via decayWeight() utility
- No regressions: existing aim logic, game flow, death/restart all work correctly
</success_criteria>

<output>
After completion, create `.planning/phases/02-ai-intelligence/02-02-SUMMARY.md`
</output>
