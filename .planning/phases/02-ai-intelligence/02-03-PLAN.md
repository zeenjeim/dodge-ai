---
phase: 02-ai-intelligence
plan: 03
type: execute
wave: 3
depends_on: [02-02]
files_modified: [index.html]
autonomous: false

must_haves:
  truths:
    - "A first-time player and a veteran player face noticeably different AI aggression levels within the same session"
    - "Threat level rises as AI detects patterns (0.0 to 1.0 scale) and modulates projectile speed, accuracy, and spawn rate"
    - "Threat level decays slightly when counter-pattern shots are dodged, creating cat-and-mouse dynamics"
    - "Session escalation cap ramps from 0.5 to 1.0 over 90 seconds, preventing instant-death starts"
    - "At max threat level (0.9+), AI cycles between zone-denial, prediction-spam, and speed-pressure modes every 12 seconds"
    - "Cross-session memory remembers returning players but threat level always starts at 0 and ramps within the session"
    - "The AI never escalates faster than 0.02 per second"
  artifacts:
    - path: "index.html"
      provides: "Threat level controller, adaptive difficulty via getPhaseDef() modifiers, endgame cycling, session cap"
      contains: "threatLevel"
  key_links:
    - from: "updateThreatLevel()"
      to: "this.threatLevel"
      via: "called from update() every frame"
      pattern: "updateThreatLevel|threatLevel"
    - from: "getPhaseDef()"
      to: "this.threatLevel"
      via: "applies threat level as modifier to base phase params"
      pattern: "threatLevel.*aimPct|threatLevel.*speed"
    - from: "updateEndgameCycle()"
      to: "this.endgameMode"
      via: "rotates attack modes at max threat"
      pattern: "endgameMode|zone-denial|prediction-spam|speed-pressure"
    - from: "spawnProjectileFromWarning()"
      to: "counterPatternChance from getPhaseDef()"
      via: "adaptive counter-pattern chance replaces fixed confidence-based chance from 02-02"
      pattern: "counterPatternChance"
---

<objective>
Add the adaptive difficulty system: a threat level controller that modulates game difficulty based on AI pattern confidence, with session escalation caps and cycling endgame patterns at max threat.

Purpose: AI-05 and AI-06 require adaptive difficulty that adjusts AI aggression based on player skill, with a per-session cap to prevent rage-quit spirals. The locked decisions demand fast escalation (30-60s to feel AI react) and inevitable death (escalates until it overwhelms). This plan makes the AI feel progressively smarter across a session while ensuring the endgame is dynamic (cycling modes per discretion decision) rather than monotonous.

Output: Modified index.html with threat level tracking, updateThreatLevel() method, modified getPhaseDef() applying threat modifiers, endgame cycling at max threat, and session cap enforcement.
</objective>

<execution_context>
@C:\Users\Zahi\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\Zahi\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@C:\Users\Zahi\claudecode\dodge-ai\.planning\PROJECT.md
@C:\Users\Zahi\claudecode\dodge-ai\.planning\ROADMAP.md
@C:\Users\Zahi\claudecode\dodge-ai\.planning\STATE.md
@C:\Users\Zahi\claudecode\dodge-ai\.planning\phases\02-ai-intelligence\02-RESEARCH.md
@C:\Users\Zahi\claudecode\dodge-ai\.planning\phases\02-ai-intelligence\02-01-SUMMARY.md
@C:\Users\Zahi\claudecode\dodge-ai\.planning\phases\02-ai-intelligence\02-02-SUMMARY.md
@C:\Users\Zahi\claudecode\dodge-ai\index.html
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add threat level controller with session cap and endgame cycling</name>
  <files>index.html</files>
  <action>
**Part A: Threat level state initialization**

In `start()` method, add threat level state (alongside existing game state resets):
```javascript
this.threatLevel = 0;
this.endgameMode = null;
this.endgameCycleTimer = 0;
this.recentCounterMisses = 0;
this._threatAtCapDuration = 0;
```

**Part B: updateThreatLevel(dt) method**

Add `updateThreatLevel(dt)` method to the Game class (near updateUI):

```javascript
updateThreatLevel(dt) {
  const maxRatePerSecond = 0.02;

  // Session cap: ramps from 0.5 to 1.0 over 90 seconds
  // This prevents instant max-difficulty starts and ensures AI-06 compliance
  const sessionCap = Math.min(1.0, 0.5 + (this.gameTime / 90) * 0.5);

  // Rise based on AI confidence and active pattern count
  const gameTimeSec = this.gameTime;
  const confidence = this.brain.getConfidence() / 100; // 0.0 to ~0.97
  const activePatterns = this.brain.getActivePatternCount(gameTimeSec);
  const riseRate = (confidence * 0.012 + activePatterns * 0.004) * dt;

  // Decay when counter-pattern shots are dodged (AI missed its read)
  // recentCounterMisses is incremented when a counter-pattern projectile goes offscreen
  let decayRate = 0;
  if (this.recentCounterMisses > 2) {
    decayRate = 0.004 * dt;
    this.recentCounterMisses = Math.max(0, this.recentCounterMisses - dt * 0.5); // Slowly reset counter
  }

  // Apply with rate limit and session cap
  const netChange = Math.min(riseRate, maxRatePerSecond * dt) - decayRate;
  this.threatLevel = Math.min(sessionCap, Math.max(0, this.threatLevel + netChange));
}
```

Call `updateThreatLevel(dt)` from `update()` (line 1870), right after `brain.trackPosition()` call (line 1908):
```javascript
this.updateThreatLevel(dt);
```

**Part C: Track counter-pattern misses for threat decay**

In the projectile off-screen check (around line 2015-2018, where `this.dodgedCount++` happens), add counter-miss tracking:
```javascript
if (p.isOffscreen(this.w, this.h) && (p.type !== 'bouncer' || p.bounces >= p.maxBounces)) {
  this.dodgedCount++;
  if (p.isCounter) this.recentCounterMisses++;
  this.projectiles.splice(i, 1);
}
```

**Part D: updateEndgameCycle(dt) method**

Add `updateEndgameCycle(dt)` method to the Game class:

```javascript
updateEndgameCycle(dt) {
  if (this.threatLevel < 0.9) {
    this._threatAtCapDuration = 0;
    this.endgameMode = null;
    return;
  }

  this._threatAtCapDuration += dt;

  // Start cycling after 5 seconds at max threat
  if (this._threatAtCapDuration < 5) return;

  this.endgameCycleTimer += dt;
  const cycleDuration = 12; // seconds per mode
  const modeIndex = Math.floor(this.endgameCycleTimer / cycleDuration) % 3;
  const modes = ['zone-denial', 'prediction-spam', 'speed-pressure'];
  const newMode = modes[modeIndex];

  if (newMode !== this.endgameMode) {
    this.endgameMode = newMode;
    const modeMessages = {
      'zone-denial': 'Locking down your safe zones. Good luck finding a new one.',
      'prediction-spam': 'Full prediction mode activated. I know where you\'re going.',
      'speed-pressure': 'Speed increase. Try to keep up.',
    };
    this.showLearningMessage('taunt', modeMessages[newMode]);
  }
}
```

Call `updateEndgameCycle(dt)` from `update()`, right after `updateThreatLevel(dt)`:
```javascript
this.updateEndgameCycle(dt);
```

**Part E: Modify getPhaseDef() to apply threat level modifiers**

The existing `getPhaseDef()` (line 1851) returns base phase params. Modify it to apply threat level as a multiplier AFTER computing the base values. The threat level modifies the RETURNED object, not the PHASE_DEFS constants (keeping PHASE_DEFS immutable per research pitfall #6).

Replace the entire `getPhaseDef()` method:

```javascript
getPhaseDef() {
  let base;
  if (this.phase < PHASE_DEFS.length - 1) {
    base = { ...PHASE_DEFS[this.phase] };
  } else {
    // EVOLVED: ramp values dynamically without mutating originals
    const phaseDurations = PHASE_DEFS.slice(0, 5).reduce((s, p) => s + p.dur, 0);
    const t = Math.max(0, this.gameTime - phaseDurations);
    const ramp = Math.floor(t / 20);
    base = {
      ...EVOLVED_BASE,
      speed: 6.0 + ramp * 0.4,
      spawnRate: Math.max(0.2, 0.35 - ramp * 0.03),
      count: Math.min(6, 4 + Math.floor(t / 30)),
      homingChance: Math.min(0.5, 0.3 + Math.floor(t / 30) * 0.05),
      splitterChance: Math.min(0.4, 0.3 + ramp * 0.02),
      bouncerChance: Math.min(0.3, 0.2 + ramp * 0.02),
      waveChance: Math.min(0.3, 0.2 + ramp * 0.02),
      accelChance: Math.min(0.35, 0.25 + ramp * 0.02),
    };
  }

  // Apply threat level modifiers (adaptive difficulty)
  const tl = this.threatLevel || 0;
  const result = {
    ...base,
    aimPct: Math.min(0.98, base.aimPct + tl * 0.12),
    speed: base.speed + tl * 1.2,
    spawnRate: base.spawnRate * (1 - tl * 0.2),
    counterPatternChance: tl * 0.5,
  };

  // Endgame mode modifiers (cycling at max threat)
  if (this.endgameMode) {
    switch (this.endgameMode) {
      case 'zone-denial':
        // Heavy zone targeting: massively boost counter-pattern chance
        result.counterPatternChance = Math.min(0.8, result.counterPatternChance + 0.3);
        break;
      case 'prediction-spam':
        // More predictive shots: boost aim accuracy
        result.aimPct = Math.min(0.99, result.aimPct + 0.08);
        result.homingChance = Math.min(0.5, (result.homingChance || 0) + 0.1);
        break;
      case 'speed-pressure':
        // Faster, more frequent projectiles
        result.speed += 1.5;
        result.spawnRate = Math.max(0.15, result.spawnRate * 0.7);
        break;
    }
  }

  return result;
}
```

**Part F: Update counter-pattern chance in spawnProjectileFromWarning()**

In `spawnProjectileFromWarning()`, the counter-pattern firing logic from Plan 02-02 uses `this.brain.getConfidence() / 100 * 0.4` as the counter chance. Replace this with the adaptive `counterPatternChance` from getPhaseDef():

Find the counter-pattern block added in Plan 02-02 and change:
```javascript
// OLD: const counterChance = this.brain.getConfidence() / 100 * 0.4;
// NEW: Use adaptive counter-pattern chance from threat level
const counterChance = def.counterPatternChance || 0;
```

This uses `def` which is already available (line 2414: `const def = this.getPhaseDef()`).

**Part G: Save threat level history**

In `brain.save()`, add threat level to the saved data so returning players' difficulty history is tracked:
```javascript
threatLevelHistory: [...(existing.threatLevelHistory || []).slice(-4), this.threatLevel || 0].slice(-5),
```

This keeps the last 5 session peak threat levels for future reference (Phase 3 share card could use this).
  </action>
  <verify>
1. Search for `threatLevel` -- should appear in start(), updateThreatLevel(), getPhaseDef(), and brain.save()
2. Search for `updateThreatLevel` -- should be a method called from update()
3. Search for `updateEndgameCycle` -- should be a method called from update()
4. Search for `endgameMode` -- should appear in getPhaseDef() switch statement
5. Search for `counterPatternChance` -- should appear in getPhaseDef() return and spawnProjectileFromWarning()
6. Search for `recentCounterMisses` -- should appear in start(), projectile off-screen check, and updateThreatLevel()
7. Search for `sessionCap` -- should appear in updateThreatLevel()
8. Open in browser, play for 60+ seconds: difficulty should noticeably ramp up (faster projectiles, more accurate shots, more counter-pattern shots). At ~45-60s, the game should feel significantly harder than the first 15s
9. Console check: `window._game.threatLevel` -- should be a number between 0 and 1 that grows during gameplay
  </verify>
  <done>Threat level controller tracks AI adaptation from 0.0 to 1.0 with session cap ramping from 0.5 to 1.0 over 90s. Rate limited at 0.02/s. Decays when counter-shots are dodged. getPhaseDef() applies threat modifiers to speed, accuracy, spawn rate, and counter-pattern chance. Endgame cycles between zone-denial, prediction-spam, and speed-pressure modes every 12s at max threat. Threat history saved to localStorage.</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 2: Verify AI intelligence feels smart, fair, and adversarial</name>
  <what-built>
Complete Phase 2 AI intelligence system:
- 4 pattern detectors (direction bias, safe zone, dodge sequence, panic)
- Adaptive difficulty with threat level 0.0 to 1.0
- Counter-pattern projectile firing with purple glow visual distinction
- Learning callout messages (detection, counter-attack, taunts, welcome-back)
- Session escalation cap (ramps 0.5 to 1.0 over 90s, max +0.02/s)
- Endgame cycling modes (zone-denial / prediction-spam / speed-pressure) at max threat
- Cross-session memory with welcome-back taunts for returning players
  </what-built>
  <how-to-verify>
1. **Fresh start test**: Clear localStorage, open index.html. Play for 60+ seconds:
   - First 10-15s: no callouts, normal difficulty
   - ~15-25s: first detection callout appears (e.g., "You dodge right NN% of the time. Adorable.")
   - ~25-40s: counter-pattern shots appear (purple glow) with counter callouts ("Aiming there", "Targeting your safe zone")
   - ~40-60s: difficulty noticeably harder (faster projectiles, more accurate, more counters)
   - Callouts never spam (8-12s cooldown between messages)

2. **Returning player test**: Die, start a new game:
   - Welcome-back taunt appears ~1.5s in ("Oh, you're back. Still dodging right?")
   - AI remembers your patterns but threat level starts at 0 (not instant death)

3. **Behavior change test**: Die, restart. Deliberately dodge LEFT instead of right:
   - AI should gradually shift callouts to acknowledge new pattern
   - Old pattern not mentioned indefinitely (decay works)

4. **Endgame test**: Survive 60+ seconds. Check console: `window._game.threatLevel` should be near cap. Watch for endgame cycling callouts ("Locking down your safe zones", "Full prediction mode", "Speed increase").

5. **Edge case checks**:
   - `window._game.threatLevel` is a number between 0 and 1
   - Reset AI button clears all data and removes welcome-back taunts
   - No console errors during any of the above

6. **Feel check** (subjective):
   - Does the AI feel adversarial and smug, not helpful?
   - Do counter-pattern shots feel like the AI "read" you, not random?
   - Does death feel earned (you got outplayed) not cheap (difficulty spike)?
   - Is the purple glow on counter shots visible but not distracting?
  </how-to-verify>
  <resume-signal>Type "approved" if the AI intelligence feels smart and fair, or describe specific issues to fix</resume-signal>
</task>

</tasks>

<verification>
1. Fresh game, first 15s: only brain panel updates, no callout messages, base difficulty
2. After 15-25s: first pattern detection callout fires (if player has a detectable pattern)
3. After 25-40s: counter-pattern projectiles appear with purple glow and explicit counter callouts
4. Difficulty ramps: `window._game.threatLevel` grows from 0 toward session cap
5. Session cap: threat level never exceeds the 0.5 + (gameTime/90)*0.5 formula
6. Rate limit: threat level never jumps more than 0.02 per second
7. Counter-shot dodged: threat level decays slightly
8. Endgame: at threatLevel 0.9+, modes cycle every 12s with mode-specific callouts
9. Returning player: welcome-back taunt on game start, threat starts at 0
10. Reset AI: all data cleared, fresh start experience
11. No console errors, no performance degradation
</verification>

<success_criteria>
- Threat level controller implemented (0.0 to 1.0 scale)
- Session cap ramps 0.5 to 1.0 over 90 seconds
- Rate limited at max 0.02/second
- getPhaseDef() applies threat modifiers without mutating PHASE_DEFS
- Endgame cycles between 3 modes every 12 seconds at max threat
- Counter-pattern chance driven by threat level (not fixed confidence ratio)
- Threat decays when counter-shots are dodged
- Returning players start at threat 0 with pattern memory (not max difficulty)
- Threat level history saved to localStorage
- Human verification: AI feels smart, fair, and adversarial
</success_criteria>

<output>
After completion, create `.planning/phases/02-ai-intelligence/02-03-SUMMARY.md`
</output>
